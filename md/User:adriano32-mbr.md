Опишу для начала, как преобразовать типичную вендоразметку накопителей.

## Вступление

Итак, вкратце о разделах:

Для того, чтобы хранить данные на накопителе, на нём обычно создают
специального рода разметку — таблицу разделов, виртуально разделяя
всё дисковое пространство для логической организации данных на части.
То есть на поверхности накопителя между разделами демаркационную линию
не процарапывают, разделение на разделы можно легко поменять — в
специально условленной области накопителя в определённом формате
записывается информация об этих разделах. Из этих условленных мест в
0-ом секторе размещение и тип разделов считывают все кому не лень,
начиная от загрузчика ядра, заканчивая самой ОС, не говоря об
утилитах для манипулирования этими таблицами разделов.

## Кратко о MBR

Существует несколько видов таких разметок, далее речь идёт о разметке
MBR.

При этой схеме разметки основная таблица разделов создаётся в 0-ом
секторе накопителя. Она представляет из себя четыре записи (по
записи на раздел) по 16 байт каждая в конце 0-го сектора, за
которыми идут два байта 0x55aa сигнатуры
(подписи-идентификатора) MBR. Таким образом
ориентируемся на последние 64+2=66 байт 0-го сектора, причём
последние два обязательно должны быть 0x55aa. Если последние два
байта 0-го сектора не равны 0x55aa, возможно, у вас другая схема
разметки и дальнейшее чтение и тем более выполнение каких-либо
действий чревато потерей текущей таблицы разделов.

Как же увидеть основную таблицу разделов? Если у вас в системе
установлены утилиты *dd* (disk dump) и *hd* (hexadecimal dump)
или её аналоги *xxd* или *od -t x1*, то выполните следующие команды,
считая, что /dev/hda — целевой накопитель:

    root@linux# blockdev --getss /dev/hda
    512
    root@linux# echo `blockdev --getss /dev/hda`-66 | bc
    446
    root@linux# dd if=/dev/hda bs=1 count=66 skip=446 | hd -v
    00000000  80 01 01 00 07 fe ff 7b  3f 00 00 00 3d a8 da 00  |.......{?...=...|
    00000010  00 00 c1 7c 0f fe ff ff  7c a8 da 00 45 3c 76 08  |...|....|...E<v.|
    00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    66+0 records in
    66+0 records out
    00000040  55 aa                                             |U.|
    00000042
    66 bytes (66 B) copied, ?.???????? s, ??.? kB/s

Первой командой мы узнали физический размер сектора накопителя, второй
командой высчитали смещение в первом секторе, третьей считали 66 байт
по расчитанному смещению и передали через конвейер шестнадцатиричному
просмотрщику.

## Структура записи

О структуре каждой из четырёх записей подробно написано [на
википедии](http://en.wikipedia.org/wiki/Master_boot_record),
Для быстрого вхождения в суть вопроса обычно достаточно знания
нескольких полей:

  - нулевой байт 0x80 или 0x00 — отметка активности (boot flag) раздела
  - четвёртый байт 0x83 или 0x07 или 0x0f или 0x05 и др. — тип файловой
    системы раздела, [полный перечень тоже на
    википедии](http://en.wikipedia.org/wiki/Partition_type).
    Linux 0x83 если что.
  - байты с восьмого по одиннадцатый включительно (3f 00 00 00, 7c a8 da
    00 в приведённом примере) — номер стартового сектора раздела от
    младшего байта к старшему, то есть 0x7c — младший байт, 0x00 —
    старший. Сами hex-числа соответсвенно 0x0000003f и 0x00daa87c.
  - байты с двенадцатого по пятнадцатый включительно (3d a8 da 00, 45 3c
    76 08 в приведённом примере) — количество секторов в разделе от
    младшего байта к старшему, то есть 0x45 — младший байт, 0x08 —
    старший. Сами hex-числа соответсвенно 0x00daa83d и 0x08763c45.

## Primary vs Extended

Теперь же собственно о разделах и почему надо менять разметку.

В главной таблице разделов могут присутствовать разделы двух типов:
первичные (primary) и расширенные (extended).

Изначально существовали только первичные разделы. Но поскольку записей
всего 4, то соответственно в основной таблице разделов может храниться
всего 4 первичных раздела. Это не всегда согласуется с желанием
пользователя организовать данные на накопителе.

Например, если я хочу вынести /, /boot, /var, /usr, /tmp, /home, /opt на
разные разделы, очевидно, что у меня не получится обойтись первичными
разделами.

На помощь приходит расширенный раздел, внутри которого можно создать
ограниченное лишь размером этого расширенного раздела количество
внутренних (логических) разделов. При этом размещение и тип этих
логических разделов хранятся в специальных областях этого
расширенного раздела (об этом подробнее далее).

То есть информация о логических разделах выносится за пределы 0-го
сектора, в 0-ом сектор записан один расширенный раздел, но ОС или
загрузчик получив информацию о границах расширенного раздела получают
информацию о логических разделах внутри расширенного, считывая данные
известным образом из определённых областей расширенного раздела, в
которых указаны границы логических разделов. Общей таблицы, где
хранились бы все логические разделы "в столбик" тоже нет.

Чтобы определить, как размечен ваш накопитель, выполните

    root@linux# blockdev --report

В результате вы увидите перечень разделов, если среди них есть разделы с
номерами выше пятого — у вас есть расширенный раздел и логические
разделы внутри него.

## Плюсы и минусы

Итак, в чём же плюсы и минусы, как и почему стоит делать?

Прежде чем переходить к сравнению, нужно рассказать, как хранится
информация о логических разделах внутри расширенного.

В вышеприведённом примере второй раздел — расширенный, его стартовый
сектор, как мы разобрались выше 0x00daa87c. Переведём в десятичную
систему для наглядности и понятности одним из нижеприведённых
способов.

    root@linux# echo $((0x00daa87c))
    14329980
    root@linux# printf '%d\n' 0x00daa87c
    14329980
    root@linux# echo "ibase=16;obase=A;"`echo 00daa87c | tr '[:lower:]' '[:upper:]'` | bc
    14329980

Итак, в секторе 14329980 начало расширенного раздела, там находится
такая же точно по структуре запись, как и в 0-ом секторе

    root@linux# echo 14329980*512+446 | bc
    7336950206
    root@linux# dd if=/dev/hda bs=1 count=66 skip=7336950206 | hd -v
    00000000  00 01 c1 7c 07 fe ff ff  3f 00 00 00 7c eb 57 01  |...|....?...|.W.|
    00000010  00 fe ff ff 05 fe ff ff  bb eb 57 01 f8 11 f4 01  |..........W.....|
    00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    66+0 records in
    66+0 records out
    00000040  55 aa                                             |U.|
    00000042
    66 bytes (66 B) copied, ?.???????? s, ??.? kB/s

В этой записи первый раздел — «псевдо»-первичный и соответствует первому
логическому диску, а второй «псевдо»-расширенный и соответствует
воображаемому расширенному разделу, в который входят все
остальные логические разделы.

Обратите внимание, что нумерация начального сектора и количества
секторов указана в относительно первого сектора расширенного
раздела (14329980) — вместо 14329980+63=14330043 написано просто 63.

Это очень важный момент: нумерация секторов внутри расширенного раздела
относительна, причём каждый следующий логический раздел расположен
внутри «псевдо»-расширенного со своей относительной нумерацией
секторов, выполняемой от начала этого «псевдо»-расширенного
раздела.

В этом втором «псевдо»-расширенном разделе, как я сказал, хранятся все
остальные логические разделы, расчитаем его начальный сектор в
абсолютных единицах (от начала накопителя, то есть от нулевого
сектора) и убедимся, что в этом секторе снова такая же структура, как
в 0-ом секторе и в первом секторе обычного (не «псевдо») расширенного
раздела.

    root@linux# echo $((0x0157ebbb))+14329980 | bc
    36869175
    root@linux# echo 36869175*512+446 | bc
    18877018046
    root@linux# dd if=/dev/hda bs=1 count=66 skip=18877018046 | hd -v
    00000000  00 01 c1 ff 07 fe ff ff  3f 00 00 00 b9 11 f4 01  |........?.......|
    00000010  00 fe ff ff 05 fe ff ff  b3 fd 4b 03 f8 11 f4 01  |..........K.....|
    00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    66+0 records in
    66+0 records out
    00000040  55 aa                                             |U.|
    00000042
    66 bytes (66 B) copied, ?.???????? s, ??.? kB/s

В итоге получается такая своеобразная матрёшка из разделов внутри
расширенного раздела.

Выглядит оно выходит что так

<div style="text-align:center;border: 5px #f88 solid;">

<div style="float: left;border: 5px #00f solid;">

MBR

</div>

<div style="float: left;border: 5px #077 solid;">

sda1

</div>

<div style="float: left;border: 5px #777 solid;">

<div style="float: left;border: 5px #fff solid;">

sda2

</div>

<div style="float: left;border: 5px #00f solid;">

PT\#0

</div>

<div style="float: left;border: 5px #077 solid;">

sda5

</div>

<div style="float: left;border: 5px #f0f solid;">

<div style="float: left;border: 5px #fff solid;">

E\#1

</div>

<div style="float: left;border: 5px #00f solid;">

PT\#1

</div>

<div style="float: left;border: 5px #770 solid;">

sda6

</div>

<div style="float: left;border: 5px #0f0 solid;">

<div style="float: left;border: 5px #fff solid;">

E\#2

</div>

<div style="float: left;border: 5px #00f solid;">

PT\#2

</div>

<div style="float: left;border: 5px #f00 solid;">

sda7

</div>

<div class="clear">

</div>

</div>

<div class="clear">

</div>

</div>

<div class="clear">

</div>

</div>

<div class="clear">

</div>

</div>

Расшифровка такова:

  - MBR — нулевой сектор накопителя с основной таблицей разделов, в
    данном примере содержит один первичный раздел и один
    расширенный
  - sda1 — первый раздел, первичный, являющийся единственным в данном
    примере первичным разделом
  - sda2 — второй раздел, расширенный, являющийся единственным в данном
    примере расширенным разделом
  - PT\#0 — таблица разделов в нулевом секторе расширенного раздела
    накопителя, содержит информацию о первом логическом разделе и
    первом «псевдо»-расширенном разделе E\#1.
  - sda5 — собственно первый логический раздел
  - E\#1 — первый «псевдо»-расширенный раздел, внутри которого
    расположены все остальные логические разделы кроме первого
  - PT\#1 — таблица разделов в нулевом секторе первого
    «псевдо»-расширенного раздела E\#1, содержит
    информацию о втором логическом разделе и втором
    «псевдо»-расширенном разделе E\#2.
  - sda6 — собственно второй логический раздел
  - E\#2 — второй «псевдо»-расширенный раздел, внутри которого
    расположены все остальные логические разделы кроме первого
    и второго
  - PT\#2 — таблица разделов в нулевом секторе второго
    «псевдо»-расширенного раздела E\#2, содержит
    информацию о третьем логическом разделе и больше ни о чём,
    поскольку третий логический раздел является последним логическим
    разделом в данном примере, а соответственно необходимости в третьем
    «псевдо»-расширенном разделе E\#3 нет.
  - sda7 — собственно третий логический раздел

Итак, пора взвесить плюсы и минусы первичных и расширенных разделов.

Плюсы первичных:

  - информация о границах первичных разделов хранится в чётко
    определённой позиции накопителя — в нулевом секторе и не
    зависит от размеров разделов, как в случае с логическими дисками,
    информация о границах каждого следующего из которых фактически
    находится за концом предыдущего.
  - не существует каких-либо проблем с загрузкой некоторых ОС (на
    практике нельзя например установить QNX Neutrino в логический
    раздел, по поводу последних версий WINDOWS нужна информация, можно
    ли устанавливать их в логический раздел)
  - удобство и понятность выполняемых вручную операций по расчёту с
    номерами секторов благодаря тому, что используются абсолютные
    единицы — от начала накопителя (0-го, то есть стартового сектора)

Минусы первичных:

  - первичных разделов может быть не больше четырёх
  - грохнуть нулевый сектор очень просто (достаточно перепутать аргумент
    output file — of у команды dd, указав вместо нужного пункта
    назначения файл блочного устройства накопителя, — и скорее
    всего вы нажмёте Ctrl+c — ^C уже после, как нулевой сектор
    накопителя будет перезаписан), при этом естественно
    информация о границах первичных разделов теряется (что
    говорит о необходимости иметь резервную копию таблицы разделов
    в нулевом секторе или всей MBR) и при отсутствии информации о
    границах первичных разделов или резервной копии нулевого
    сектора (MBR) нужен софт для восстановления разделов (Testdisk,
    например), тогда как вышеуказанная ошибка с аргументом output file —
    of у команды dd затрёт расширенный раздел, но скорее всего не
    затронет разметки логических разделов внутри расширенного
    (если вы вовремя прервёте команду или размер записанных поверх
    накопителя данных в секторах меньше, чем номер стартового сектора
    расширенного раздела. Преимущество структуры с одним первичным и
    одним расширенным разделом с кучей логических в том, что как
    только найдено начало расширенного раздела, спецсофт тут же
    внесёт его в MBR, и все логические разделы станут доступны,
    тогда как для восстановления в MBR первичных разделов требуется
    найти начала всез этих разделов — как следствие более длительная
    операция поиска.
  - стартовый (нулевой) сектор некоторых накопителей (NAND-флешек)
    сильно подвержен быстрому износу, особенно на файловых
    системах, где файловая таблица попадает в пределы первого
    физического блока NAND: частая перезапись приводит к быстрому
    исчерпанию ресурса циклов перезаписи этого блока, следствием
    чего является быстрый выход из строя или проблемы, связанные с
    повреждением разметки (лично у меня были две флешки Transcend,
    которые отказывались видеть свой собственный раздел).

Плюсы расширенных разделов и логических внутри них:

  - неограниченное число логических разделов внутри расширенного
  - энтропия (случайность) расположения данных о границах логических
    разделов из-за индивидуальности разметки каждого накопителя
    резко понижает вероятность того, что сектор, содержащий эту
    важную информацию о начале раздела и количесвте секторов в нём,
    будет повреждён случайной перезаписью или выходом из строя блока
    или области диска.

Минусы расширенных разделов и логических внутри них:

  - непрозрачная структура нумерации секторов, каждый логический раздел
    помещён в свой «псевдо»-расширенный раздел, нумерация в котором
    относительна от его начала. При большом количестве логических
    разделов немудрено и запутаться.
  - информация о границах логических разделов внутри расширенного
    разбросана по всему расширенному разделу — собрать её не так
    сложно, но не так легко, как инфу о первичных разделах

## Пример преобразования логического раздела в первичный

Ниже я изложу последовательность действий, которая с высокой чтепенью
точности решит поставленную задачу — преобразовать логический раздел
в первичный. Если вы взвесили все за и против, или вам перестало
нравится наличие расширенного раздела при том, что имеются
свободные места в MBR для первичных — без какой-либо
ответственности за результат, но с высокой гарантией успеха
благодаря, продуманному алгоритму и максимально возможным
резервированиям изменяемых на накопителе структур таблиц
разделов перед вносимыми правками — вы можете проследовать по
нижеизложенному плану действий.

Далі буде...
