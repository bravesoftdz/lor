Существует множество способов локализации своих приложений. Наиболее распространенным является использование <code>gettext</code>, но бывают случаи, когда необходим более простой способ локализации, когда перевод "вшит" в бинарник (и когда языков немного).
== Статическая локализация ==
Для локализации простого двуязычного приложения (например, CGI) можно использовать статическую локализацию.
Суть такой локализации в том, что заранее отдельно создаются строковые массивы, содержащие фразу на обоих языках. В зависимости от языка пользователя из массива выбирается фраза с нужным индексом.

Определим макросы <tt>_LANG</tt> и <tt>_L</tt>, которые позволяют выбрать нужный текст в зависимости от текущего языка. Язык определяется переменной <tt>Lang</tt>:
<code lang="C"><pre style="white-space: pre-wrap;">
#define		_LANG(_var, _ru, _en)	char _var##ru[] = _ru;\
					char _var##en[] = _en;\
					char *_var[2] = {_var##ru,  _var##en};
#define		_L(x)	(x[Lang])
unsigned char Lang = 1; // по умолчанию - английский
</pre></code>

Макрос <tt>_LANG</tt> инициализирует очередной массив с именем <tt>_var</tt> двумя строками - следующими аргументами. Чтобы вывести нужный текст, используется макрос <tt>_L</tt>, который просто выводит нужную строку из массива, в зависимости от языка.
Вот пример использования этого метода:
<code lang="C"><pre style="white-space: pre-wrap;">
char *ptr = getenv("HTTP_ACCEPT_LANGUAGE");
if(ptr && strncmp(ptr, "ru", 2) == 0) Lang = 0;
...
printf("%s:<input ... >\n", _L(_s_Name_));
</pre></code>

Отдельно необходимо будет заполнить массив с фразами на русском и английском языке:
<code lang="C"><pre style="white-space: pre-wrap;">
_LANG(_s_Name_, "Ваше имя", "Your name");
</pre></code>

Достоинства этого метода: в одном бинарнике содержится все, т.е. меньше шансов при переносе CGI из одного хранилища в другое "потерять" локализацию. Минусы тоже очевидны: приходится отдельно подготавливать строковые массивы, а в месте использования правильно указать название массива. Еще один минус: для добавления еще одного языка придется править исходники и перекомпилировать приложение.

== Динамическая локализация ==
Gettext - стандартный способ локализации. В отличие от статической локализации он требует наличия еще как минимум одного дополнительного файла (mo-файл), в котором содержится база данных локализации для функции <tt>gettext</tt>. Т.к. локализация лежит отдельно, ее всегда можно подправить, не влезая в нутро исходников программы.
Однако, при работе с <tt>gettext</tt>'ом выбор нужной фразы производится в реальном времени: для отображения фразы в соответствии с настройками локали, в базе данных для текущей локали ищется английская фраза (запакованная в макрос <tt>gettext</tt>). Если есть фраза на нужном языке, она выводится <tt>gettext</tt>'ом, иначе - отображается фраза на английском.

Средства работы с <tt>gettext</tt> автоматизированы: утилита <code>xgettext</code> выбирает из исходников нужные фразы (оформленные определенным макросом) и помещает их в po-файл, а утилита <code>poedit</code> позволяет редактировать po-файлы (кроме того, их можно редактировать вручную).

База данных (mo-файл) для каждой локали формируется при помощи утилиты msgfmt из текстового po-файла (который, кстати, тоже отдельный для каждой локали). Так как в процессе разработки зачастую приходится к уже имеющемуся po-файлу с переводом добавлять новые фразы, есть удобная утилита msgmerge, добавляющая лишь новые, не переведенные, фразы. Естественно, в <code>cmake</code> есть макросы для работы с <tt>gettext</tt>, так что разработчкику все сделать достаточно просто.

Чтобы было удобно работать с <code>xgettext</code>, необходимо определить какие-то простые макросы для <tt>gettext</tt>, например:
<code lang="C"><pre style="white-space: pre-wrap;">
#define _(String)				gettext(String)
#define gettext_noop(String)	String
#define N_(String)				gettext_noop(String)
</pre></code>

В этом случае, например, фраза <code>printf(_("Capture frame %d\n"), j);</code> при запуске <code>xgettext</code> с обозначением разделителей как <code>-k_ -kN_</code> создаст po-файл, в котором будут строки
<code lang="C"><pre style="white-space: pre-wrap;">
msgid   "Capture frame %d\n"
msgstr  ""
</pre></code>
<tt>msgid</tt> - идентификатор нашего сообщения (т.е. само сообщение на английском), а <tt>msgstr</tt> - это же сообщение на другом языке.

Подготовив такой файл, переведя его и сформировав из него при помощи <code>msgfmt</code> базу данных для нашей локали, мы сможем видеть перевод. Но для этого еще необходимо будет указать <tt>gettext</tt>'у, где искать mo-файл. Это делается при помощи функций
<code lang="C"><pre style="white-space: pre-wrap;">
bindtextdomain(GETTEXT_PACKAGE, LOCALEDIR);
textdomain(GETTEXT_PACKAGE);
</pre></code>

Макросы <tt>GETTEXT_PACKAGE</tt> и <tt>LOCALEDIR</tt> определяются обычно при подготовке компиляции (например, тем же <code>cmake</code>). <tt>LOCALEDIR</tt> - путь к директории, в которой лежат файлы локализации (если мы хотим русифицировать приложение, в директории <tt>LOCALEDIR</tt> должна быть вложена директория <tt>ru/LC_MESSAGES</tt>, где <tt>ru</tt> - нужный нам язык, <tt>LC_MESSAGES</tt> - сами сообщения (по значению этой переменной и определяется язык, кстати).

Чтобы оформить все это в <tt>CMakeLists.txt</tt>, достаточно указать, что нам необходимо подключить нужные библиотеки для работы <tt>gettext</tt> и найти <code>xgettext</code> (если po-файл еще не сформирован):
<code lang="C"><pre style="white-space: pre-wrap;">
find_package(Gettext REQUIRED)
find_program(GETTEXT_XGETTEXT_EXECUTABLE xgettext)
</pre></code>

Введем макросы:
* <tt>PO_FILE</tt> - po-файл, формируемый <code>xgettext</code>;
* <tt>RU_FILE</tt> - переведенный po-файл (в который будут добавляться новые данные при помощи msgmerge);
* <tt>MO_FILE</tt> - mo-файл (т.е. сама база данных - только он и нужен в конечном итоге).

Тогда для генерирования po- и mo-файлов "на лету" нам нужно дописать в <tt>CMakeLists.txt</tt>:
<code lang="C"><pre style="white-space: pre-wrap;">
add_custom_command(
	OUTPUT ${PO_FILE}
	COMMAND ${GETTEXT_XGETTEXT_EXECUTABLE} --from-code=koi8-r ${SOURCES} -c -k_ -kN_ -o ${PO_FILE}
	COMMAND sed 's/charset=UTF-8/charset=koi8-r/' ${PO_FILE} | enconv > tmp && mv -f tmp ${PO_FILE}
	COMMAND ${GETTEXT_MSGMERGE_EXECUTABLE} -Uis ${RU_FILE} ${PO_FILE}
	DEPENDS ${SOURCES})
add_custom_command(
	OUTPUT ${MO_FILE}
	COMMAND ${GETTEXT_MSGFMT_EXECUTABLE} ${RU_FILE} -o ${MO_FILE}
	DEPENDS ${RU_FILE})
</pre></code>
(локаль у меня - КОИ8, поэтому необходимо указать входную локаль для <code>xgettext</code>'а, а также подкорректировать неправильное отображение локали в формируемом po-файле.

;Облегчение работы переводчика
:Ключ <tt>-c</tt> позволяет в po-файл добавлять строку с комментариями, расположенными до строки, где встречается макрос, указанный в аргументе ключа <tt>-k</tt>. Таким образом, если в комментариях сразу писать перевод на русский язык, можно даже будет автоматизировать создание готового po-файла с переводом.


Если все выполнить правильно и не забыть скопировать mo-файл по указанному пути, то после запуска приложение должно "заговорить" на родном для вашей локали языке.