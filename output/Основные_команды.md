## Получение справки о командах.

### man - вызов справки

Эта команда выводит на экран страницу оперативной справки по заданной
команде. Например, для того чтобы посмотреть на документацию по
команде *ls*, выполните команду:

    $ man ls

В большинстве случаев вывод команды *man* включает в себя следующие
разделы:

  - NAME - Имя команды и краткое описание.
  - SYNOPSIS - Формат вызова команды.
  - DESCRIPTION - Подробное описание возможностей команды.
  - OPTIONS - Перечисление опций, предусмотренных для команды. На мой
    взгляд, это самый полезный раздел.
  - FILES - Файлы, используемые командой.
  - AUTHOR - Информация об авторе программы, реализующей команду;
    Контактная информация.
  - BUGS - Обнаруженные недостатки и сведения о том, куда сообщить, если
    вы обнаружите новую ошибку.
  - COPYRIGHT - Информация об авторских правах.
  - SEE ALSO - Другие команды, имеющие отношение к рассматриваемой.

**Навигация по странице справки:**

Переход на строку вниз - клавиша со стрелкой вниз

Переход на строку вверх - клавиша со стрелкой вверх

Переход вперед на одну страницу - клавиша "F" или "Page Down"

Переход назад на одну страницу - клавиша "B" или "Page Up"

Выход - клавиша "Q"

**Поиск по справке:**

Для того чтобы отыскать данные на открытой странице, надо ввести символ
"/", затем текст, который необходимо найти и нажать "Enter". Если
искомый текст присутствует в справке, то содержимое страницы
сдвинется так, что он будет отображаться на экране. Чтобы
продолжить поиск, нужно повторно нажимать клавишу "Enter" (или
"N"). Чтобы вернуться к предыдущему показанному результату - нажать
комбинацию клавиш "Shift+N".

**Опции команды *man*:**

***man -k (или --apropos)*** -- Позволяет организовать поиск по слову
или фразе, описывающей команду. Особенно полезно, когда не знаешь
какая именно команда нужна. На экран выводится список команд, для
которых либо имя совпадает с ключевым словом, либо это слово
находится в разделе SYNOPSIS.

Пример использования: *man -k list*

<u>Опция -k или ее полный вариант --apropos делает тоже, что и команда
apropos.</u>

***man -f (или --whatis)*** -- Позволяет получить краткие сведения о
команде. На экран выводится данные раздела SYNOPSIS.

Пример использования:'' man -f ls''

<u>Опция -f или ее полный вариант --whatis это аналог команды
whatis.</u>

***man -u (или --update)*** Эта опция вызывает принудительное
формирование базы данных команд, которую использует команда
*man*. Иногда бывает так, что информация по команде отсутствует, именно
в таких случаях стоит воспользоваться данной опцией.

***man \[1-8\]*** Страницы справочного руководства распределены по
разделам с номерами от 1 до 8.

1.  Команды общего назначения.
2.  Низкоуровневые системные вызовы.
3.  Функции библиотеки C.
4.  Специальные файлы. (Устройства в каталоге /dev).
5.  Информация о форматах файлов и соглашения.
6.  Игры.
7.  Различная информация. Сведения о макропакетах.
8.  Команды системного администрирования, вызываемые пользователем
    *root*.

***man -t (или --troff)*** Вывод справочной информации на печать.

Пример использования:'' man -t ls | lrp -P hp_laserjet'' Где,
hp_laserjet - идентифицируемый в системе принтер. (Команду lrp смотреть
отдельно).

Также можно создать файл формата PDF. Для этого наберите в командной
строке следующее:

    $ man -t ls > ls.ps && ps2pdf && ls.ps && rm ls.ps

-----

### info - вызов справки (альтернативный вариант)

В рамках проекта **GNU** был разработан альтернативный формат руководств
*man* - info-страницы, для доступа к которым используется команда info.

В отличии от man-страниц содержимое страниц info подается в виде
разделов и подразделов, называемыми узлами и подузлами
соответственно.

Пример использования:

    $ info info

**Навигация в системе info:**

Переход на строку вниз - клавиша со стрелкой вниз

Переход на строку вверх - клавиша со стрелкой вверх

Переход вниз на одну страницу - клавиша "Page Down" или "Пробел" или
"Bs" или "Delete". Если вы достигните конца раздела, то перейдете к
следующему разделу (или подразделу) если таковой имеется. Используя
клавиши "Пробел", "Bs" или "Delete" - вы можете просмотреть весь набор
info-страниц для конкретной команды.

Переход вверх на одну страницу - клавиша "Page Up"

Если вы достигли конца раздела, переход в начало - клавиша "B"

Обновить страницу - клавиши "Ctrl+L"

Чтобы переместится к следующему разделу нажмите клавишу "N". Обратно -
клавиша "P". Таким образом вы будете перемещаться по разделам
пропустив все подразделы, переход будет осуществлен на
следующий или предыдущий раздел (или подраздел) того же уровня,
что вы просматривали.

Чтобы перейти к следующему элементу, независимо от того, является он
разделом или подразделом надо использовать клавишу "\]". К
предыдущему - "\["

Переместится к вышестоящему или родительскому узлу - клавиша "U"

переход к "корневому узлу" Directory - клавиша "D"

Выход из системы info - клавиша "Q"

**Поиск по системе info:**

В системе info предусмотрено два варианта поиска:

1\. Поиск по заголовкам. Введите "i" затем ключевое слово и нажмите
"Enter", если ключевое слово присутствует в заголовках, вы можете
перейти к соответствующему узлу. Можно также повторить поиск и
перейти к следующему результату, для этого введите "," (запятую).

2\. Поиск по всему тексту. Введите "s" затем ключевое слово или фразу и
нажмите "Enter". Для того чтобы повторить поиск, надо непосредственно
после клавиши "Enter" нажать клавишу "S" (сделать это сложновато).

Вызов помощи в системе info осуществляется нажатием клавиши "?". В
нижней части экрана отобразятся команды системы info. Перемещаться
в этом разделе помогают клавиши со стрелками. Чтобы отменить подсказку
нажмите клавиши "Ctrl+X", затем, отпустив их, нажмите клавишу "0".

-----

### whatis - краткое описание команды

Данная команда является аналогом команды *man* с опцией *-f* и выводит
на экран описание команды, содержащееся на страницах справочного
руководства.

Пример использования:

    $ whatis ls

Опции:

    -w - Включает возможность поиска в базе с использованием групповых операций.
    -r - Включает возможность поиска в базе с использованием регулярных выражений

Регулярные выражения могут немного замедлять работу.

-----

### apropos - поиск команды по ключевому слову

Данная команда является аналогом команды *man* с опцией *-k*. Ищет в
кратких описаниях справочных страниц ключевые слова и показывает
любые совпадения.

Пример использования:

    $ apropos list

Опции:

    -w - Включает возможность поиска в базе с использованием групповых операций.
    -r - Включает возможность поиска в базе с использованием регулярных выражений.
    -e - Осуществляет поиск в точности по ключевому слову.

-----

## Основные операции с файлами

### ls - вывод списка файлов в директории

Команда *ls* выводит список атрибутов файлов и директорий.

Вы можете вывести список файлов в текущей директории:

    $ ls

В заданных директориях:

    $ ls dir1 dir2 dir3

или для отдельных файлов:

    $ ls file1 file2 file3

По умолчания команда *ls* скрывает файлы имена которых начинаются с
точки.

Опции:

    -a - Выводит список всех файлов, включая файлы, названия которых начинаются с точки.
    -l - Осуществляет подробный вывод, включая атрибуты файлов (Добавьте опцию -h "human-readable", чтобы размер файлов выводился в килобайтах, мегабайтах, гигабайтах вместо байтов).
    -F - Помечает имена определенных файлов целевыми символами, указывающими на тип файлов. Приписывает "/" к директориям, "*" к исполняемым файлам, "@" к символьным ссылкам, "|" к именованным каналам и "=" к сокетам. Это просто визуальные индикаторы, они не являются частью имени файла.
    -i - Добавляет к выводу информационные дескрипторы (inode) файлов.
    -s - Добавляет размер файла в блоках. Полезно для сортировки по по размеру: $ ls -s | sort -n
    -R - При выводе содержимого директории выводит рекурсивно дерево подкаталогов с их содержимым.
    -d - При выводе содержимого директории выводит имена каталогов так, как если бы они были обычными файлами, а не показывает их содержимое.
    -m - Выводит содержимое каталога с запятыми вместо разделителей.
    -r - Выводит информацию о файлах в обратном порядке.
    -x - Выводит содержимое с сортировкой по суффиксам имен файла.
    -t - Выводит содержимое с сортировкой по дате и времени.
    -S - Выводит содержимое с сортировкой по размеру файла.

-----

### cp - копирование

Данная команда просто копирует файл:

    $ cp source_file dest_file

или копирует несколько файлов в директорию

    $ cp srcfile1 srcfile2 dest_dir

Опции:

    -a - Копировать иерархию директорий рекурсивно, сохраняя специальные файлы, права, символьные ссылки и жесткие ссылки. Эта опция комбинирует в себе опции -R, -p и -d.
    -R - Осуществляет рекурсивное копирование.
    -p - Копирует не только содержимое файла, но и права на файл и временные метки, его владельца и группу.
    -d - Копирует, помимо содержимого файла, символьные и жесткие ссылки на файл.
    -i - Интерактивный режим. Выдает предупреждение прежде чем перезаписать уже существующий файл.
    -f - Перезаписывать файлы без предупреждения если такие уже есть.
    -v Предоставляет подробную информацию о действиях выполняемых командой.

-----

### mv - переименование/перемещение

Данная команда может либо переименовывать файлы:

    $ mv original_file_name new_file_name

или перемещать файлы и директории в другую директорию:

    $ mv file1 file2 file3 destination_dir

Опции:

    -i - Интерактивный режим. Выдает предупреждение, прежде чем перезаписать существующий файл.
    -f - Перезаписывает файлы без предупреждений.

-----

### rm - удаление

Данная команда может удалять файлы:

    $ rm file1

или директории:

    $ rm -r dir

Опции:

```

-i - Интерактивный режим. Выдает предупреждение, прежде чем удалить какой-либо файл.
-f - Удаляет файлы, игнорируя любые ошибки и предупреждения.
-r - Рекурсивно удаляет директории. Используйте с осторожностью с опцией -f.
-v - Выводит все действия команды.
```

-----

### ln - создание ссылки/(альтернативного имени) на файл

Ссылка (Link) - это созданный командой *ls* указатель на другой файл.
Существует два варианта таких ссылок:

1\. Символьная ссылка - Указывает на файл по его пути.

    $ ln -s myfile softlink

2\. Жесткая ссылка - просто второе название физического файла на диске.
Удаление оригинального файла не делает такую ссылку неработоспособной.

    $ ln myfile hardlink

Опции:

    -s - Создает символьную ссылку. По умолчанию создает жесткую ссылку.
    -i - Интерактивный режим. Выдает предупреждение, прежде чем перезаписать существующий файл.
    -f - Перезаписывает файлы (если они уже есть) без предупреждений.
    -d - Позволяет суперпользователю создать жесткую ссылку на директорию.

Посмотреть, куда указывает символьная ссылка (например, link1), можно
любой из команд:

    $ readlink link1

или:

    $ ls -l link1

-----

## Работа с директориями

### cd - смена директории

-----

Изменение текущей директории. Например:

    user@host:~$ cd /bin
    user@host:~/bin$

Использование cd без параметров возвращает вас в домашний каталог.

    user@host:~/bin$ cd
    user@host:~$

### pwd - вывод текущей директории

Команда *pwd* выводит абсолютный путь вашей текущей рабочей директории.

    $ pwd
    /home/user/somedirectory

В bash аналогичную смысловую нагрузку несет переменная PWD.

### basename - вывод последней части пути к файлу

Команда *basename* выводит последний компонент пути к файлу.

    $ basename /home/user/dir1
    dir1

### dirname - отбросить последнюю часть пути к файлу

Команда *dirname* отбрасывает последний компонент пути к файлу.

    $ dirname /home/user/dir1
    /home/user

Команда *dirname* просто обрабатывает строку, которая является именем
директории. Она не изменяет вашу текущую директорию.

### mkdir - создать директорию

Данная команда может создать одну:

    $ mkdir dir

или несколько директорий:

    $ mkdir dir1 dir2 dir3

**Опции команды *mkdir*:**

'''''-p ''''' Если вы указываете путь к директории (а не просто имя
директории), то команда создаст все необходимые директории
автоматически. Например команда:

    $ mkdir -p /one/two/three/dir

создаст директории /one /one/two и /one/two/three если они не
существуют, а затем и саму директорию /one/two/three/dir

***-m*** Создает директорию с заданными правами. Пример использования:

    $ mkdir -m 0755 dir1

-----

### rmdir - удалить пустую директорию

Данная команда удаляет **пустые** директории:

    $ rmdir dir

Для удаления **не пустых** директорий и их содержимого, используйте
команду *rm*

**Опции команды *rmdir*:**

'''''-p ''''' Если вы указываете путь к директории (а не просто имя
директории), то команда удалит все директории автоматически.
Например команда:

    $ rmdir -p /one/two/three/dir

Удалит не только директорию /one/two/three/dir , но и директории
/one/two/three /one/two и /one, если они пусты.

-----

## Просмотр файлов

В Linux вам нужно будет просматривать различные типы файлов: текст,
Postscript, двоичные данные и множество других. Обратите внимание что, в
данном подразделе не рассматриваются команды для просмотра графических и
аудио-видео файлов.

-----

### cat - просмотреть файл целиком

Простейшей программой просмотра является *cat*, которая просто копирует
файлы в стандартный поток вывода объединяя их. Так же *cat* умеет
управлять своими выходными данными, опционально отображая
непечатаемые символы, номера строк и игнорируя пробелы.

Пример использования.

    $ cat file1 file2
    В лесу родилась елочка.
    <....>
    в траве сидел кузнечик
    <....>

**Опции команды *cat*:**

'''''-T ''''' Выводить знаки табуляции в виде ^|

'''''-E ''''' Выводить символы новой строки в виде $

'''''-v ''''' Выводить другие непечатаемые символы в удобном для
восприятия формате

'''''-n ''''' Присоединять в начале каждой строки ее номер

'''''-b ''''' Присоединять в начале каждой непустой строки ее номер

'''''-s ''''' Заменить каждую последовательность пустых строк одной
пустой строкой.

Вообще говоря, *cat* в основном полезен для отправки набора файлов в
конвейер, но в очень редких и специфичных случаях, так как
подавляющее большинство команд могут читать как со
стандартного ввода, так и напрямую из файла, поэтому
конвейер вида

    cat file | grep string

можно переписать проще и быстрее в виде

    grep string file

-----

### less - просмотреть файлы постранично

Команда *less* используется для постраничного просмотра текста. Она
хорошо подходит для чтения текстовых файлов или в качестве
последней команды в конвейере с большими выходными данными.

При выполнении команды *less* нажмите клавишу *h* для вывода справочного
сообщения, описывающего все ее возможности. (Функций у команды *less*
очень много, я опишу лишь самые общие из них. Советую почитать
man-страницу).

| **Клавиша или комбинация** | **Функция**                                                                            |
| -------------------------- | -------------------------------------------------------------------------------------- |
| h, H                       | Просмотреть справочную страницу                                                        |
| Пробел, f, ^V, ^F          | Перейти на один экран вперед                                                           |
| b, ^B, ESC-b               | Перейти на одну строку вперед                                                          |
| /                          | Перейти в режим поиска. Укажите после этого регулярное выражение и нажмите *Enter*     |
| ?                          | То же самое что и ***/*** но поиск будет производится в обратном направлении по файлу. |
| n                          | Повторить последний поиск                                                              |
| N                          | Повторить последний поиск в обратном направлении                                       |
| v                          | Редактировать текущий файл вашим стандартным редактором (По умолчанию vi)              |
| \<                         | Перейти в начало файла                                                                 |
| \>                         | Перейти в конец файла                                                                  |
| ":n" (без кавычек)         | Перейти к следующему файлу                                                             |
| ":p" (без кавычек)         | Перейти к предыдущему файлу                                                            |
|                            |                                                                                        |

**Опции команды *less*:**

'''''-c ''''' Очищать экран перед тем, как отобразить следующую страницу

'''''-m ''''' Вывод информации о том, какая часть файла выведена на
данный момент (в процентах)

'''''-N ''''' Выводить номера строк

'''''-r ''''' Выводить управляющие (непечатаемые) символы.

'''''-s ''''' Объединять несколько пустых строк в одну

'''''-S ''''' Урезать длинные строки до длины экрана вместо переноса

-----

### head - просмотреть первые строки файла

Команда *head* печатает первые 10 строк файла, полезно для
предварительного просмотра файлов.

    $ head file

**Опции команды *head*:**

'''''-N ''''' или '''''-n N ''''' Вывести первые N строк вместо 10.

'''''-c N ''''' Вывести первые N байт файла

'''''-q ''''' Тихий режим: При обработке более чем одного файла выводить
заголовок над каждым файлом. Обычно *head* выводит заголовок, содержащий
имя файла.

-----

### tail - просмотреть последние строки файла

Команда *tail* Выводит последние 10 строк файла.

    $ tail file

**Опции команды *head*:**

'''''-N ''''' или '''''-n N ''''' Вывести последние N строк вместо 10.

'''''+N ''''' Вывести все строки, кроме первых N строк

'''''-c N ''''' Вывести последние N байт файла

'''''-f ''''' Оставить файл открытым и, если в него будут потом
добавляться строки, выводить их.

'''''-q ''''' Тихий режим: При обработке более чем одного файла выводить
заголовок над каждым файлом. Обычно *head* выводит заголовок, содержащий
имя файла.

-----

### nl - просмотреть файлы с пронумероваными строками

Команда *nl* выводит содержимое указанных файлов, добавляя перед каждой
строкой ее номер. Команду *nl* можно использовать двумя способами: с
простыми текстовыми файлами со специальными размеченными текстовыми
файлами с предопределёнными верхними и нижними колонтитулами, также
можно делить текстовые файлы на виртуальные страницы с разными
схемами нумерации. Для этого необходимо в файлах задать
определенную разметку:

**Разметка файла**

***\\:\\:\\:*** Начало верхнего колонтитула.

'''''\\:\\: ''''' Начало тела.

***\\:*** Начало нижнего колонтитула.

Каждый элемент разметки должен вставляться в отдельной строке.

    $ nl file1 file2

**Опции команды *nl*:**

'''''-b \[a|t|n|pR\] ''''' Добавлялять номера ко всем строкам (a),
непустым строкам (t), не нумеровать строки (n), нумеровать только
те строки, которые содержат регулярное выражение (R). (по умолчанию
(a))

'''''-v N ''''' Начать нумерацию с целого числа N (по умолчанию с 1)

'''''-i N ''''' Увеличивать номер на N для каждой следующей строки.

'''''-n \[ln|rn|rz\] ''''' Выравнивать номера влево (ln), вправо (rn),
вправо с добавлением нулей в начале (rz).

'''''-w N ''''' Ширина номера должна равняться N колонкам (по умолчанию
- 6).

'''''-s S ''''' Вставить строку S между номером строки и текстом (по
умолчанию - TAB)

-----

### od - просмотреть файлы в восьмиричной системе (или других форматах)

Команда *od* выводит содержимое двоичных файлов в восьмеричном,
десятичном, шестнадцатеричном форматах и в формате с плавающей
точкой, различных размеров (byte, short, long)

    $ od -w8 /usr/bin/who

    0044340 066156 073145 066145 020040
    0044350 020040 071160 067151 020164
    0044360 072543 071162 067145 020164
    0044370 072562 066156 073145 066145
    0044400 020012 026440 026163 026440
    0044410 071455 067550 072162 020040
          [Полный вывод пропущен]

**Опции команды *od*:**

'''''-N B ''''' Вывести только первые *B* байт файла (каждого файла), в
десятичном, шестнадцатеричном (с префиксом 0x или 0X) форматах, в
блоках по 512 байт (с суффиксом b), килобайтах (с суффиксом k) или
мегабайтах (с суффиксом m). По умолчанию выводится весь файл.

'''''-j B ''''' Начать вывод с (B+1)-го байта файла (каждого файла).
Форматы такие же как у опции '''''-N '''''. По умолчанию вывод с
0-го байта.

'''''-w \[B\] ''''' Выводить по B байт в строке. Форматы такие же как у
опции '''''-N ''''', использование -w без аргументов, дает тот же
результат, что '''''-w32 '''''. По умолчанию выводится по 16 байт
в строке.

'''''-s \[B\] ''''' группировать данные в строках в группы по *B* байт,
разделенные пробелами. Форматы такие же как у опции '''''-N ''''',
использование -s без аргументов, дает тот же результат, что
'''''-s3 '''''. По умолчанию группировка по 2 байта.

'''''-A (d|o|x|n) ''''' Отображать смещение от начала файлав самой левой
колонке в десятичном (d), в восьмеричном (o), шестнадцатеричном (h)
форматах, или не отображать совсем (n).

'''''-t (a|c)\[z\] ''''' Вывести данные в символьном формате,
непечатаемые символы выводить в виде ESC-последовательностей
(a), либо в виде названий (c).

***-t (d|o|u|x) \[SIZE\[\[z|z\]\]*** Вывести данные в целочисленном
формате, включая восьмеричный (o), десятичный (d), десятичный без
знака (u), шестнадцатеричный (x). SIZE представляет размерность целого
числа в байтах и может быть любым числом из значений char, short, int
или long.

'''''-t f\[SIZE\[\[z|z\]\] ''''' Вывести данные в формате с плавающей
точкой. SIZE может быть любым числом из значений float, double или
long double.

-----

### xxd - просмотреть файлы в шестнадцатиричной системе

Команда *xxd* выводит содержимое файла в шестнадцатеричном или двоичном
формате. Также можно осуществлять обратное преобразование из
шестнадцатеричного формата в исходный код.

    $ xxd /usr/bin/who

    0005470: ff89 c1e9 7ff7 ffff 8b95 b4fc ffff 85d2  ................
    0005480: 0f88 9505 0000 8b85 b4fc ffff 01c0 83c0  ................
    0005490: 0c0f 8284 0500 0039 85b4 fcff ff0f 83a9  .......9........
    00054a0: f6ff ff83 bdb4 fcff ff00 0f85 ed07 0000  ................
    00054b0: c785 b4fc ffff 0c00 0000 3985 b4fc ffff  ..........9.....
    00054c0: 7306 8985 b4fc ffff 83bd b4fc ffff ff0f  s...............
    00054d0: 8403 f5ff ff8b 8d70 fcff ff39 8db0 fcff  .......p...9....
    00054e0: ff0f 94c3 89de 0f84 c207 0000 8b85 b0fc  ................
    00054f0: ffff 85c0 0f84 b407 0000 8b95 b4fc ffff  ................
    0005500: 8b8d b0fc ffff 8954 2404 890c 24e8 4ab6  .......T$...$.J.

          [Полный вывод пропущен]

Команда xxd, по умолчанию, осуществляет вывод данных в три колонки:
смещение от начала файла, данные в шестнадцатеричном представлений
и данные в виде текста (только печатаемые символы)

**Опции команды *xxd*:**

'''''-l N ''''' Вывести только первые *N* байт файла. По умолчанию
выводится весь файл.

'''''-s N ''''' или '''''-s -N ''''' Выводить не с начала файла. Первый
вариант пропускает первые *N* байт. Второй вариант (-N) выводит *N*
байт с конца файла.

'''''-c N ''''' Выводить по *N* байт в строке. По умолчанию выводится по
16 байт в строке.

'''''-g N ''''' Группировать данные в строках *N* байт, разделенные
пробелами. По умолчанию группировка по 2 байта.

'''''-b ''''' Выводить данные в двоичном, а не в шестнадцатеричном
формате.

'''''-u ''''' Выводить данные в шестнадцатеричном формате в верхнем, а
не в нижнем регистре.

***-p*** Выводить данные в простом шестнадцатеричном формате, по 60 байт
в строке.

'''''-i ''''' Вывести данные в виде структуры данных языка
программирования C.

'''''-r ''''' Обратное преобразование из шестнадцатеричного вывода в
исходный формат файла.

-----

### gv - просмотреть Postscript или PDF файлы

Программа GhostView отображает Script- или PDF-файлы в графическом окне.
Вы можете вызвать ее с помощью команд *gv* или *ghostview*.

Работа в программе очень проста и интуитивно понятна.

**Опции *gv*:**

'''''-page P ''''' Начать с P-й страницы. По умолчанию с 1-й.

'''''-monochrome ''''' Задать режим вывода: монохромный.

'''''-color ''''' Задать режим вывода: цветной.

'''''-grayscale ''''' Задать режим вывода: оттенки серого.

***-portrait***, ***-landscape***, ***-seascape***, '''''-upsidedown
''''' Задать ориентацию страницы. По-умолчанию - определяется
автоматически.

'''''-scale N ''''' Задать коэффициент масштабирования для вывода. При N
положительном изображение будет больше, при отрицательном - меньше.

'''''-watch ''''' При изменении Postscript-файла автоматически
перегружать его. Или не делать этого, опция: '''''-nowatch
'''''

-----

### xdvi - просмотреть TeX DVI-файлы

Система обработки документов TeX создает двоичные выходные файлы в
формате DVI, с расширением *.dvi* Программа *xdvi* выводит
DVI-файлы в графическом окне.

При выводе файла программа предоставляет колонку кнопок с функциями для
навигации. Также Вы можете перемещаться по файлу с помощью "горячих
клавиш", то есть с помощью команд с клавиатуры:

| **Клавиша или комбинация**   | **Функция**                                                                                           |
| ---------------------------- | ----------------------------------------------------------------------------------------------------- |
| q                            | Выход                                                                                                 |
| n, Пробел, Enter, PageDown   | Перейти на одну страницу вперед. Набрав перед нажатием число N, вы переместитесь на N страниц вперед. |
| p, BackSpace, Delete, PageUp | Перейти на одну страницу назад. Набрав перед нажатием число N, вы переместитесь на N страниц назад.   |
| \<                           | Перейти к первой странице.                                                                            |
| \>                           | Перейти к последней странице                                                                          |
| ^L                           | Обновить страницу.                                                                                    |
| R                            | Перечитать DVI-файл.                                                                                  |
| Нажатие кнопок мыши.         | Увеличить прямоугольную область под курсором мыши.                                                    |
|                              |                                                                                                       |

Программа *xdvi* имеет множество командных опций для изменения цветов,
геометрии, масштаба,и поведения программы в целом.

-----

### grep — Поиск текста соответствующего регулярному выражению в файлах или потоке вывода

Название представляет собой акроним английской фразы «search
**g**lobally for lines matching the **r**egular **e**xpression, and
**p**rint them» — «искать везде строки, соответствующие регулярному
выражению, и выводить их».

**Синтаксис**

    grep [ОПЦИИ] ШАБЛОН [ФАЙЛЫ]

**Опции:**

**-r** Искать во всех каталогах рекурсивно

**-n** Выводит номера строк, в которых найдено совпадение

**-l** Вывести только список файлов содержащих шаблон

**-v** Искать строки не содержащие шаблон (инверсия)

**-i** Игнорировать регистр

**-F** Воспринимать шаблон не как регулярное выражение, а как строку
(увеличивает скорость поиска). Также есть команда *fgrep*, которая
делает то же самое

**-P** Воспринимать шаблон как регулярное выражение языка Perl.

**Примеры**

    user@linux$ grep -riF 'hello' world/*         #Искать подстроку «hello» во всех файлах внутри каталога «world» и его подкаталогов игнорируя регистр символов
    user@linux$ grep -l '^hello' *                #Вывести список файлов в данном каталоге которые начинаются с подстроки «hello»
    user@linux$ grep -nv 'hello$' 'myfile.txt' .  #Искать строки, которые заканчиваются подстрокой «hello» в файле «myfile.txt» и выводить номера этих строк
    user@linux$ cat myfile.txt | grep -vF 'hello' #Искать строки, содержащие подстроку «hello» в файле «myfile.txt»
    user@linux$ history | fgrep 'ping'            #Искать подстроку «ping» в истории командной строки
    user@linux$ grep -P "[\x80-\xff]" myfile      #Искать символы из второй половины однобайтной кодовой таблицы в файле myfile

\---

## Создание и редактирование файлов.

### touch - Обновление временной метки файла.

Устанавливает время последнего изменения и доступа в текущее системное
время у файла myfile.txt. Если файл не существует - он создается.

    # touch myfile.txt

Устанавливает дату последнего изменения и доступа в 8:46:26 31 января
2007 г.:

    # touch -t 200701310846.26 index.html
    # touch -d '2007-01-31 8:46:26' index.html
    # touch -d 'Jan 31 2007 8:46:26' index.html

**Опции:** touch \[-acfhm\] \[-r файл\] \[-t
\[\[CC\]YY\]MMDDhhmm.\[SS|CC\]YY\]MMDDhhmm.\[SS\]\] файл

` -a`
`  Устанавливает время последнего доступа к файлу. Время последнего изменения не устанавливается, если явно не задан ключ -m`
`  -c`
`  Указывает утилите не создавать файл, если он не существует, при этом никаких сообщений об ошибке показано не будет.`
`  -f`
`  Пытается обновить информацию о времени, даже если права доступа файла не позволяют делать.`
`  -h`
`  Указывает утилите не изменять данные о файле, если он задан символической ссылкой.`
`  -m`
`  Устанавливает время последнего изменения файла.`
`  -r file`
`  Использовать значения времени из файла, заданного аргументом file.`
`  -t time`
`  Устанавливает время последнего изменения и доступа в соответствии с указанным форматом time.`

Формат даты, указанный в ключе -t задается в соответствии с шаблоном
\[\[СС\]YY\]MMDDhhmm\[.SS\]:

` СС — первые две цифры года (век).`
`  YY — последние две цифры года.`
`  Если параметр CC не задан и значение YY находится в пределах 69 и 99, то тогда СС устанавливается равным 19,`
`  в противном случае используется 20.`
`  MM — двузначный номер месяца.`
`  DD — двузначный номер дня.`
`  hh — значение часов даты.`
`  mm — значение минут даты.`
`  SS — значение секунд даты.`

-----

### umask - Задать маску прав доступа для новых файлов и директорий.

Права доступа файлов, созданных при конкретном значении umask,
вычисляются при помощи следующих побитовых операций (umask
обычно устанавливается в восьмеричной системе счисления): побитовое
И между унарным дополнением аргумента (используя побитовое НЕ) и
режимом полного доступа.

Режим полного доступа для файлов — 666, для директорий — 777. Многие
оболочки UNIX предоставляют команду umask, которая влияет на все
дочерние процессы, исполняемые в этой оболочке.

Пример:

```
 $ umask 0174
 $ mkdir директория
 $ touch файл
 $ ls -l
 drw-----wx 2 dave dave 512 Sep  1 20:59 директория
 -rw-----w- 1 dave dave   0 Sep  1 20:59 файл
```

-----

## Свойства файла

### stat - Вывести атрибуты файлов и директорий

Выводит содержимое полей дескрипторов файла или файловой системы.

Пример:

    $ stat install-cyg-apt.sh
      File: `install-cyg-apt.sh'
      Size: 140             Blocks: 1          IO Block: 65536  regular file
    Device: 44951982h/1150622082d   Inode: 281474976926170  Links: 1
    Access: (0700/-rwx------)  Uid: ( 1000/    user)   Gid: (  513/    None)
    Access: 2011-12-04 17:19:09.389000000 +0200
    Modify: 2009-10-30 14:53:13.000000000 +0200
    Change: 2011-12-04 17:19:09.389000000 +0200
     Birth: 2011-12-04 17:19:09.389000000 +0200

Опции:

    -c --format=FORMAT
     применяется указанный формат вывода FORMAT, вместо используемого по умолчанию
    -f, --filesystem
     выводит статус файловой системы (на которой расположен FILE) вместо статуса файла
    -L, --dereference
     выводит информацию о статусе оригинального файла, с которым связана ссылка FILE
    -t, --terse
     выводит информацию в сокращённой (сжатой) форме
    --help
     выводит это описание программы и завершает её работу
    --version
     выводит информацию о версии программы и завершает её работу

-----

### wc - Подсчитать количество байт, слов, строк в файле

Пример использования:

    $ wc ideas.txt excerpt.txt
         40     149     947 ideas.txt
       2294   16638   97724 excerpt.txt
       2334   16787   98671 total

**Опции команды wc:**

`  wc -l `<filename>` вывести количество строк`
`  wc -c `<filename>` вывести количество байт`
`  wc -m `<filename>` вывести количество символов`
`  wc -L `<filename>` вывести длину самой длинной строки`
`  wc -w `<filename>` вывести количество слов`

-----

### du - Показать, сколько места занимают на диске файлы и директории

Подсчитать размер заданной директории в байтах:

    $ du -s Downloads
      22520024      Downloads

Подсчитать размер занимаемый текущей директорией и вывести размер в
удобном виде:

```
$ du -sh
  26G
```

Подсчитать размер в мегабайтах размер папок и их общий размер:

    $ du -scm Downloads doc

**Опции:**

    -a, --all
     Показывать размеры для всех встретившихся файлов, а не только для каталогов.
    -b, --bytes
     Выдавать размеры в байтах вместо килобайтов.
    --block-size=количество
     Выдавать размеры в блоках длиной количество байт. (Новое в fileutils-4.0.)
    -c, --total
     Выдавать общий итог по всем аргументам после того, как все аргументы будут обработаны. Это может быть использовано для выяснения суммарного использованного дискового пространства для всего списка заданных файлов и каталогов.
    -D, --dereference-args
     Раскрывать символьные ссылки, заданные в командной строке. Не оказывает влияния на остальные символьные ссылки. Это полезно для поиска использованного дискового пространства в таких каталогах, как /usr/tmp, которые часто являются символьными ссылками.
    --exclude=шаблон
     При рекурсивном выполнении пропускать каталоги или файлы, чьи имена совпадают с заданным шаблоном. Этот шаблон может быть любым файловым шаблоном Bourne shell. (Новое в fileutils-4.0.)
    -h, --human-readable
     Добавлять букву размера, например M для двоичного мегабайта (`мебибайт'), к каждому размеру.
    -H, --si
     Делает то же, что и опция -h, но использует официальные единицы измерения SI (где для расчетов используется 1000 вместо 1024 и, таким образом, M - это 1000000 вместо 10485576). (Новое в fileutils-4.0.)
    -k, --kilobytes
     Выдавать размеры в KiB (бинарных килобайтах, 1024 байта).
    -l, --count-links
     Подсчитывать размеры всех файлов, даже если они уже встречались (например, при использовании жестких ссылок).
    -L, --dereference
     Раскрывать символьные ссылки (показывать дисковое пространство, используемое файлом или каталогом, на которые указывает ссылка, вместо пространства, используемого самой ссылкой).
    -m, --megabytes
     Выдавать размеры в MiB (бинарных мегабайтах, 1048576 байтов).
    --max-depth=n
     Выдавать общий итог для каталога (или файла, если задана опция -a ), только если он находится не более чем на n уровней глубины ниже заданного в командной строке аргумента; --max-depth=0 означает то же самое, что и опция -s . (Новое в fileutils-4.0.)
    -s, --summarize
     Выдавать только суммарный итог для каждого аргумента.
    -S, --separate-dirs
     Выдавать отдельно размер каждого каталога, не включая размеры подкаталогов.
    -x, --one-file-system
     Пропускать каталоги, находящиеся не на той же файловой системе, что и обрабатываемый аргумент командной строки.
    -X файл, --exclude-from=файл
     Выполняет те же действия, что и опция --exclude, за исключением того, что шаблоны берутся из указанного файла. Шаблоны перечисляются по одному на строку. Если файл задан как `-', то шаблоны читаются из стандартного ввода. (Новое в fileutils-4.0.)

-----

### file - Определить тип файла

Утилита выполняет серию тестов и делает попытку классифицировать его.

    $ file install-cyg-apt.sh
    install-cyg-apt.sh: a /usr/bin/sh script, ASCII text executable

Опции:

    -f file: Считывает из указанного файла список файлов для проверки.
    -L : Определяет тип файлов, указанных по ссылке.
    -z : Определяет тип файлов, находящихся в сжатых файлах.

-----

### chown - Изменить владельца файлов и директорий

Изменить владельца (owner) для /var/run/httpd.pid на root

    chown root /var/run/httpd.pid

Поменять имя владельца для base на us рекурсивно:

    chown -R us base

**Опции:**

    chown [-cfhvR] [--dereference] [--reference=rfile] пользователь[:группа] файл…
    -c, --changes
    Подробно описывать действие для каждого файла, владелец которого действительно изменяется.
    -f, --silent, --quiet
    Не выдавать сообщения об ошибках для файлов, чей владелец не может быть изменён.
    -h, --no-dereference
    Работать с самими символьными ссылками, а не с файлами, на которые они указывают. Данная опция доступна только если имеется системный вызов lchown.
    -R, --recursive
    Рекурсивное изменение владельца каталогов и их содержимого.
    -v, --verbose
    Подробное описание действия (или отсутствия действия) для каждого файла.
    --dereference
    Изменить владельца файла, на который указывает символьная ссылка, вместо самой символьной ссылки.
    --reference=rfile
    Изменить владельца файла на того, который является владельцем файла.

-----

### chgrp - Изменить группу файлов и директорий

Может использоваться непривелигированными пользователями. В отличие от
команды chown, chgrp позволяет рядовым пользователям изменять группы,
но только те, членами которых они являются.

Пример:

```
 $ ls -l ttt
 -rw-r--r--   1 gbeeker  staff           545 Nov 04 2004  ttt
 $ chgrp system ttt
 $ ls -l ttt
 -rw-r--r--   1 gbeeker  system          545 Nov 04 2004  ttt
```

**Опции:**

    -R
    Рекурсивное изменение группы для каталогов и их содержимого. Возникающие ошибки не прекращают работы команды.
    -H (полулогический метод)
    (Используется совместно с -R.) Для каждого аргумента, который является символьной ссылкой на каталог, изменить группу самого каталога и всех файлов в иерархии этого каталога.
    -L (логический метод)
    (Используется совместно с -R.) Для каждого файла, указанного ли в командной строке, или встреченного при обходе дерева каталогов, если этот файл является символьной ссылкой на каталог, изменить группу самого этого каталога и всех файлов в иерархии этого каталога.
    -P (физический метод)
    (Используется совместно с -R.) Для каждого файла, указанного ли в командной строке, или встреченного при обходе дерева каталогов, если этот файл является символьной ссылкой, изменить группу самой этой ссылки, а не объекта, на который она указывает. Если система не поддерживает группы для символьных ссылок, то ничего не делать. Это поведение по умолчанию.
    -c, --changes
    Подробно описывать действия для каждого файла, чья группа действительно изменяется.
    -f, --silent, --quiet
    Не выдавать сообщения об ошибке для файлов, чья группа не может быть изменена.
    -h, --no-dereference
    Работать с самими символьными ссылками, а не с файлами, на которые они указывают. Данная опция доступна только если имеется системный вызов lchown.
    -v, --verbose
    Подробно описывать действие или отсутствие действия для каждого файла.
    --help
    Выдать подсказку на стандартный вывод и успешно завершиться.
    --version
    Выдать информацию о версии на стандартный вывод и успешно завершиться.

-----

### chmod - Изменить права доступа файлов и директорий

Права записываются сразу для трёх типов пользователей: владельца файла,
группы, в которую он входит и для прочих пользователей. Аргумент
команды chmod, задающий разрешения, может быть записан в двух
форматах: в числовом и в символьном. Для понимания сути задания прав
в Unix-like системах, нужно знать представление чисел в восьмеричной и
двоичной системах счисления:

| пользователь | группа | остальные |
| ------------ | ------ | --------- |
| 7            | 5      | 5         |
| 111          | 101    | 101       |
| rwx          | r-x    | r-x       |
| u            | g      | o         |

Пример символьной записи: "rwxr-xr-x".

Примером числовой записи может служить "755", которая эквивалентна
записанной выше строковой записи: каждое право имеет числовой код
и может быть задано вручную:

  - 400 — владелец имеет право на чтение;
  - 200 — владелец имеет право на запись;
  - 100 — владелец имеет право на выполнение;
  - 40 — группа имеет право на чтение;
  - 20 — группа имеет право на запись;
  - 10 — группа имеет право на выполнение;
  - 4 — остальные имеют право на чтение;
  - 2 — остальные имеют право на запись;
  - 1 — остальные имеют право на выполнение.

Суммировав эти коды можно получить символьную запись. Например,

    # chmod 444 {имяфайла}

400+40+4=444 — все имеют право только на чтение.

Значениями по умолчанию являются: для файлов: 644 (-rw-r--r--) для
директорий: 755 (drwxr-xr-x)

**Опции:**

    -c, --changes
     Подробно описывать действия для каждого файла, чьи права действительно изменяются.
    -f, --silent, --quiet
     Не выдавать сообщения об ошибке для файлов, чьи права не могут быть изменены.
    -v, --verbose
     Подробно описывать действие или отсутствие действия для каждого файла.
    -R, --recursive
     Рекурсивное изменение прав доступа для каталогов и их содержимого.

### setfacl - Расширенное изменение права доступа к файлам и директориям на основе списка контроля доступа (ACL)

### getfacl - просмотр расширенных права доступа к файлам и директориям на основе списка контроля доступа (ACL)

### chattr - изменяет атрибуты файлов на файловой системе ext2fs

Формат символьного режима: +-=\[ASacDdIijsTtu\].

Оператор «+» обозначает добавление указанных атрибутов к существующим;
«-» обозначает их снятие; «=» обозначает установку только этих
атрибутов файлам.

Символы «ASacDdijsu» указывают на новые атрибуты файлов:

  - не обновлять время последнего доступа к файлу atime (A)
  - синхронное обновление (S)
  - синхронное обновление каталогов (D)
  - только добавление к файлу (a)
  - сжатый (c)
  - не архивировать (d)
  - неизменяемый (i)
  - журналирование данных (j)
  - безопасное удаление (s)
  - вершина иерархического дерева (T)
  - запрет слияния в конце файла (t)
  - неудаляемый (u)

**Опции:**

    -R
    Рекурсивно изменять атрибуты каталогов и их содержимого. Все найденные символические ссылки будут игнорироваться.
    -V
    Выводит более полную выводимую информацию и версию программы chattr.
    -v версия
    Установить номер версии/генерации файла.

-----

### lsattr - Вывести список расширенных атрибутов файлов и директорий, которые могли быть установлены ранее командой chattr

Синтаксис:

```
# lsattr [ -RVadv ] [ files... ]
```

**Опции:**

    -R
     Рекурсивно выводит атрибуты каталогов и их содержимого.
    -V
     Выводит версию программы.
    -a
     Выводит информацию по всем файлам в каталогах, включая скрытые файлы, чьи имена начинаются с `.'.
    -d
     Отображает имена каталогов также, как и остальные обычные файлы (взамен вывода списков их содержимого).
    -v
     Выводит версию или номер поколения файла.

-----

## Поиск файлов

### find — Искать файл

Поиск всех файлов, начиная с корневой директории, звание которых
начинается на my

    find / -name 'my*'

**Ключи для поиска:**

    -name — искать по имени файла
    -type — по типу f=файл, d=каталог, l=ссылка(lnk)
    -user — владелец (имя или UID)

**Опции:**

    -delete — удалять найденные файлы
    -exec command {} \; — выполняет над найденным файлом указанную команду; обратите внимание на синтаксис
    -print — показывает на экране найденные файлы
    -mount — не искать в директориях, которые ведут на другие разделы диска. Эта опция должна быть указана перед опциями с параметрами (например -type и -name)

**Поиск по нескольким критериям**

Критерии поиска могут соединяться *логическим или* — опция '-o'
(сокращенно от английского *or*) и *логическим и* — опция '-a'
(сокращенно от английского *and*).

Примеры:

    user@linux$ find . \( -name "my*" -o -name "qu*" \) -print
    user@linux$ find . \( -type d -a -name "qu*" \) -print

''' Выполнение команды '''

Опция *-exec* выполняет следующую за ней команду и подставляет вместо
*{}* текущий файл.

Пример:

    user@linux$ find /path -type d -exec chmod 0755 {} \;     #Найти все каталоги ниже указанного каталога и изменить им права доступа

-----

### slocate — Создать индекс файлов и искать строку в индексе

-----

### type — Искать исполняемые файлы в директориях поиска (встроенная функция bash)

-----

### whereis - информация о месте расположения файлов

Команда *whereis* сообщает путь к исполняемому файлу программы, ее
исходным файлам (если есть) и соответствующим страницам
справочного руководства.

Пример использования:

    $ whereis bc

Опции:

    whereis -b - Вывод информации только об исполняемых файлах.

    whereis -m - Вывод информации только о страницах справочного руководства.

    whereis -s - Вывод информации только об исходных файлах.

-----

### which — Искать исполняемые файлы в директориях поиска

Пример:

    $ which firefox
    /usr/bin/firefox

Опции:

    which -a - Определяет местоположение всех исполняемых файлов.

-----

## Сжатие и упаковка файлов

### tar - Преобразует файл или группу файлов в архив без сжатия, называем тарболом (tarfile)

Упаковка файлов в архив чаще всего производится следующей командой:

***tar -cf \[имя создаваемого файла архива\] \[упаковываемые файлы и/или
директории\]***

Пример:

    user@linux$ tar -cf moi_dokumenti.tar Docs project.tex

Далее можно сжать полученный файл с помощью программы для сжатия (см.
ниже)

Распаковка содержимого архива в текущую директорию производится
следующей командой:

***tar -xf \[имя файла архива\]***

Пример:

    user@linux$ tar -xf moi_dokumenti.tar

### Создание сжатого архива в tar

Создание сжатого архива в tar производится добавлением дополнительных
ключей в команду:

    -z - gzip
    -j - bzip2
    --lzma - lzma
    -J - xz

### gzip - программа сжатия файлов

Сжатие:

    user@linux$ gzip file.txt

Распаковка:

    user@linux$ gzip -d file.txt.gz

Распаковка с сохранением исходного файла:

    user@linux$ gzip -cd file.txt.gz > file.txt

### bzip2 - программа сжатия файлов

Распаковка архива tar, сжатого bzip2:

    user@linux$ bzip2 -cd имяархива.tar.bz2 | tar -xvf -

### xz - программа сжатия файлов

Осуществляет сжатие по алгоритму LZMA. Работает медленнее bzip2 но
сжимает сильнее. Способ применения такой же как у gzip и bzip2.
Поддерживается архиватором tar.

### 7z - программа сжатия файлов

Пакет `p7zip` позволяет работать с огромным количеством типов архивов и
компрессоров. Работа с некоторыми форматами (например, rar) требует
установленных сторонних пакетов (в случае с rar это unrar).

Кроме того, 7z избавлена от знаменитой проблемы некорректного
отображения имен файлов при различии локалей системы, на
которой производилась запаковка \[сжатого\] архива, и системы, где
он распаковывался.

Основными ключами для повседневной работы с 7z являются <b>a</b>
(создание архива) и <b>e</b> или <b>x</b> (извлечение из архива,
в случае с <b>x</b> - извлечение с полными путями).

Например, чтобы создать из директории `dir` архив `archive.7z`, сжатый
компрессором 7z, достаточно ввести <code lang="bash">

    7z a archive.7z dir

</code> а чтобы извлечь содержимое архива `archive.tgz`, преобразуя пути
в относительные, написать <code lang="C">

    7z e archive.tgz

</code>

Кроме того, если на целевой машине не установлен 7z, можно создать
"самораспаковывающийся" архив (в него будет внедрен код самой
утилиты p7zip): <code lang="C">

    7z a -exe name dir

</code> создаст бинарный файл name, содержащий код распаковщика 7z и
собственно архив.

## Сравнение файлов

### cmp - сравнивает два файла, и если они различаются, сообщает о первом байте и строке, где было обнаружено различие.

Синтаксис:

```
cmp OPTIONS... FROM-FILE [TO-FILE]
```

Если возвращает 0 - различий не найдено. Если 1 - найдены. Если 2 -
обнаружена ошибка.

**Опции:**

    -c
    Печатает различающиеся символы. Отображает контрольные символы символом «^» и буквой алфавита, а также предваряет символы с установленным высшим битом символом «-M» (обозначающим «мета»).
    --ignore-initial=BYTES
    Игнорирует все различия в первых BYTES байтах входных файлов. Обращается с файлами меньшими по размеру, чем BYTES байтов, как с пустыми.
    -l
    Печатает смещение (десятичное) и значение (восьмеричное) всех различающихся байтов.
    --print-char
    Печатает все различающие символы. Отображает контрольные символы символом «^» и буквой алфавита, а также предваряет символы с установленным высшим битом символом '-M' (обозначающим «мета»).
    --quite или -s или --silent
    Ничего не печатает; только возвращает выходной статус, показывающий отличаются ли файлы.
    --verbose
    Печатает смещение (десятичное) и значение (восьмеричное) всех различающихся байтов.
    -v или --version
    Выдаёт номер версии cmp.

-----

### diff - сравнивает содержимое файла1 и файла2, и возвращает в стандартный выходной поток список изменений, необходимых для преобразования файла1 в файл2.

Если различий не найдено, ничего не возвращает.

Сравнивает 2 файла:

    $ diff file1 file2

Сравнивает 2 каталога:

    $ diff directory1 directory

**Опции:**

    -b
     Игнорировать хвостовые пробелы (символы пробела и табуляции) и считать любые строки из пробелов совпадающими.

    -i
     Игнорировать регистр символов; например, 'A' и 'a' при сравнении будут считаться совпадающими.

    -t
     Заменять символы табуляции пробелами в строках результата. Обычно или при задании опции -c в результаты добавляются символы в начале каждой строки, которые могут нарушить отступы в исходных строках, что затруднит их интерпретацию. Эта опция сохраняет отступы в исходных строках.

    -w
     Игнорировать все пробелы (символы пробела и табуляции) и считать все строки пробелов одинаковыми; например, при установке этой опции строки 'if ( a == b )' и 'if(a==b)' будут считаться совпадающими.

    Следующие опции - взаимоисключающие:
    -c
     Выдавать листинг различий с тремя строками контекста. При указании этой опции формат результата несколько изменяется: результат начинается с идентификации сравниваемых файлов и их дат создания, а затем каждое изменение отделяется строкой из двенадцати звездочек (*). Строки, удаленные из файла1, помечаются минусом (-); строки, добавленные в файл2, помечаются плюсом (+). Измененные строки в обоих файлах помечаются восклицательным знаком (!).

    -C число
     Выдает листинг различий, идентичный выдаваемому опцией -c, но с указанным числом строк контекста.

    -e
     Выдать сценарий, состоящий только из команд a, c и d редактора ed, который позволит пересоздать файл2 по файлу1. В сочетании с опцией -e, следующая командная строка интерпретатора может помочь поддерживать несколько версий файла. Необходим только исходный файл ($1) и цепочка сценариев ed для перехода от версии к версии ($2, $3, ...), построенные с помощью утилиты diff. В стандартный выходной поток будет выдана "последняя версия".
    (shift; cat $*; echo '1,$p') | ed - $1
     За исключением редких случаев, diff строит минимально достаточный набор различий между файлами.

    -f
     Выдать аналогичный сценарий с командами в обратном порядке - для редактора ed он не подходит.

    -h
     Выполнить быстрое, но приблизительное сравнение. Эта опция срабатывает только если различия невелики и легко выявляются, но зато сравнивать можно файлы неограниченной длины. Опции -c, -e, -f и -n совместно с -h использовать нельзя. Утилита diff при задании этой опции в каталоги не переходит.

    -n
     Выдать сценарий, аналогичный выдаваемому при указании опции -e, но в обратном порядке и количеством строк для каждой команды вставки или удаления.

    -D строка
     Создает общую версию файла1 и файла2 с директивами препроцессора языка C, так что при компиляции результата без определенной строки будет получено то же самое, что и при компиляции файла1, а если строка определена, - то же самое, что и при компиляции файла2.

    Следующие опции используются при сравнении каталогов:
    -l
     Выдавать результат в "длинном" формате. Перед вызовом diff, каждый файл пропускается через фильтр pr(1) для разбиения на страницы. Другие различия запоминаются и выдаются после всех различий текста в файлах.

    -r
     Применять diff рекурсивно ко всем общим подкаталогам.

    -s
     Выдавать информацию об идентичных файлах; обычно эти файлы в результатах не упоминаются.

    -S имя
     Начинает сравнение каталогов с середины, с файла с указанным именем.

-----

## Диски и файловые системы

### mount и umount - просмотр примонтированных файловых систем, монтирование\\размонтирование файловых систем

Без аргументов - список примонтированных файловых систем. С аргументами
- монтирует файловую систему в указанную точку

### df - просмотр свободного места на файловых системах

Показывает свободное место на файловых системах. Используйте df -h для
отображения свободного места в удобном для человека формате. df -h
/path - покажет свободное место, доступное по указанному пути

### fdisk - утилита для работы с разделами жесткого диска

### mkfs - группа утилит для создания файловых систем на блочных устройствах

mkfs -t ТИП - создаст файловую систему нужного типа на указанном блочном
устройстве. Альтернативный вариант - вызвать соответсвующую утилиту для
создания фс, например:

`mkfs.ext4 /dev/sdx`

## Резервное копирование и удаленное хранение данных

Список ПО вы можете найти тут: [Список По для резервного
копирования](http://ru.wikipedia.org/wiki/Список_ПО_для_резервного_копирования)

-----

## Печать файлов

## Проверка правописания

## Мониторинг процессов

### top

При запуске показывает верхушку списка процессов отсортированного по
использованию процессорного времени. Сменить поле сортировки можно
по '\>' (Shif+. на английской раскладке) и '\<'. По 'h' открывается
окно с помощью по интерактивным командам.

Можно убивать процессы: нажать 'k' и ввести номер процесса, и другое.

### htop

Делает то же что и top, но вдобавок позволяет прокручивать список
горизонтально и вертикально, поддерживает выбор процесса
стрелками или мышью для манипуляций вроде повышения приоритета
или завершения. Имеет и другие улучшения.

### ps - просмотр списка процессов

Для просмотра процессов используется команда *ps*. Однако без ключей она
чаще всего бесполезна, так как показывает запущенные процессы в текущем
терминале. Для того, чтобы посмотреть все запущенные процессы в
системе, используется ключ *-A*. Таким образом в большинстве
случаев достаточно знать следующую команду:

***ps -A***

### pidof - определение идентификатора процессов

Если известно имя процесса, но требуется узнать его идентификатор,
используется команда *pidof*. Она выводит все идентификаторы
процессов с данным именем. Синтаксис команды *pidof*:

***pidof \[имя процесса\]***

Пример:

    $ pidof bash

## Управление процессами

### kill и killall - принудительное завершение процессов

Команда *kill* принудительно завершает процесс с указанным
идентификатором. Команда *killall* - все процессы с данным
именем.

Синтаксис:

***kill \[идентификатор процесса\]***

***killall \[имя процесса\]***

Пример:

    $ kill 6583

    # killall httpd

Команда *kill* посылает сигнал процессу, в результате чего процесс
должен этот сигнал получить и соответственно повести себя. По
умолчанию процессу посылается сигнал *TERM*, однако это не всегда
помогает завершить процесс принудительно. В этих случаях имеет смысл
посылать сигнал *KILL*. Это делается следующей командой *kill* с
ключом *-9*.

Пример:

    # kill -9 2395

-----

### nice и renice - приоритет исполнения процесса

Выставление приоритета производится командой *nice* при запуске
программы.

Синтаксис:

***nice -\[приоритет\] \[команда\]***

Приоритет может быть от -20 (наибольший) до 19 (наименьший).

Пример:

    $ nice -n -8 mplayer Six\ Feet\ Under\ -\ Doomsday.avi

Следует иметь в виду, что реальный приоритет является суммой
выставляемого с приоритетом родительского процесса командной
оболочки.

Для изменения приоритета выполнения уже запущенного процесса
используется команда *renice*. Вместо запускаемой программы
указывается идентификатор процесса.

Синтаксис:

***renice -\[приоритет\] \[идентификатор процесса\]***

Пример:

    $ renice +5  3950

## Пользователи и окружение

### printenv — Вывод переменных окружения

Команда выводит все предопределенные переменные, доступные в текущей
сессии, например $XDG_CONFIG_HOME или $HOME.

## Учетные записи пользователей. Получение прав суперпользователя

### id — получение информации о пользователе

Получение имени пользователя, его uid, списка групп в которых он состоит
и, соответственно, их gid.

### adduser — добавление учётной записи пользователя

Пример использования:

    user@linux # adduser test Добавляеться пользователь 'test' ...
    Добавляеться новая группа 'test' (1002) ...
    Добавляеться новый пользователь 'test' (1002) в группу 'test' ...
    Создаётся домашний каталог '/home/test' ...
    Копирование файлов из '/etc/skel' ...
    Введите новый пароль UNIX:
    Повторите ввод нового пароля UNIX:
    passwd: пароль успешно обновлён Изминение информации о пользователе test
    Введите новое значение или нажмите ВВОД для выбора значения по умолчанию
    Полное имя []:
    Номер комнаты []:
    Рабочий телефон []:
    Домашний телефон []:
    Другое []:
    Данная информация корректна? [Д/н] Y
    user@linux #

-----

### useradd — добавление учётной записи пользователя

Пример:

    root@linux# useradd -g primary_grp -G admin -s /bin/shell -p xxxx -d /home/user

Опции:

    -d домашняя директория
    -s полный путь до оболочки (например /bin/bash)
    -p пароль
    -g (главная группа пользователя)
    -G (другие группы, к которым принадлежит пользователь)

Возможные группы:

|         |                                                                                          |
| ------- | ---------------------------------------------------------------------------------------- |
| Группа  | Описание                                                                                 |
| audio   | Возможность доступа к аудио-устройствам                                                  |
| cdrom   | Возможность прямого доступа к оптическим накопителям                                     |
| floppy  | Возможность прямого доступа к гибким дискам                                              |
| games   | Возможность играть в игры                                                                |
| usb     | Возможность прямого доступа к гибким дискам                                              |
| plugdev | Возможность монтирования и использования подключаемых устройств типа камер и USB-брелков |
| video   | Возможность доступа к средствам видеозахвата и выполнения аппаратного ускорения видео    |
| wheel   | Возможность использования команды su                                                     |

-----

### usermod — изменение учётной записи пользователя

Пример(Изменить оболочку для пользователя user):

    user@linux# usermod -s /bin/tsh user

Опции:

    -d - домашняя директория
    -s - shell (полный путь до оболочки)
    -p - пароль
    -g - главная группа пользователя
    -G - другие группы, к которым принадлежит пользователь

-----

### userdel — удаление пользователя

Пример:

    user@linux# userdel -r user

Опции:

    -r - удаление логина пользователя
    -f - немедленное удаление аккаунта, даже если пользователь находится в системе в данный момент, и удаление его домашней папки

-----

### chsh — смена оболочки пользователя

Пример (смена оболочки на csh):

    user@linux$ chsh -s csh

Опции:

    -s, --shell shell_name - смена оболочки

-----

### chfn — смена личной информации о пользователе

Опции:

    user@linux# chfn -f ФИО -r номер карты -w раб.телефон -h дом.телефон [-o другое] имя

Пример:

    user@linux# chfn -f Пупкин Василий Васильевич -r 4534534 -w 495945 -h 3942944 user

где *user* - имя пользователя.

-----

### su — быстрая смена пользователя и получение прав суперпользователя

См. соответствующий раздел статьи
[root](root#a_.D0.9A.D0.BE.D0.BC.D0.B0.D0.BD.D0.B4.D0.B0_su "wikilink")

-----

### sudo — исполнение команды от имени другого пользователя или суперпользователя

См. соответствующий раздел статьи
[root](root#a_.D0.9A.D0.BE.D0.BC.D0.B0.D0.BD.D0.B4.D0.B0_sudo "wikilink")

-----

### kdesu и gksu — выполнение графических приложений с правами суперпользователя

### w — показывающая информацию о работающих в данный момент на машине пользователях и о их процессах

### who — показывает текущих пользователей в компьютерной системе. Отличие от w в том, что who не показывает uptime

### whoami — команда, выводящая имя пользователя, ассоциированное с текущим идентификатором пользователя. В некоторых дистрибутивах на нее имеется псевдоним **who am i**

### Получение списка существующих пользователей

    user@linux$ cat /etc/passwd | cut -d: -f1

## Работа с группами

### addgroup - создание новой группы

### groupadd - создание новой группы

### groupdel - удаление группы

### groupmod - изменение группы

## Получение информации о хосте

## Поиск хоста

## Сетевые соединения

## Электронная почта

## Просмотр веб-страниц

## Вывод на экран

### Отображение всплывающих сообщений в легких WM

Чтобы иметь возможность видеть всплывающие сообщения приложений в легких
WM, необходимо в файл автозапуска WM добавить запуск одного из демонов
сообщений (notification daemon). Одним из них является xfce4-notifyd.
Однако, его проблема в том, что всплывающее сообщение отбирает фокус
ввода на себя.

Чтобы иметь возможность видеть простые всплывающие сообщения, не
мешающие вводу текста, установите простенький демон на питоне:
[notipy.py](https://launchpad.net/notipy). В автозапуск WM добавляем,
например:

    notipy.py -a SOUTH_EAST &

И наши всплывающие сообщения будут повляться в "юговосточном" (нижнем
правом) углу экрана. Проверить, как работает демон, можно просто
выполнив команду

    notify-send "Hello"

## Математические вычисления

### bc - консольный программируемый калькулятор

Данный консольный калькулятор может работать как в пакетном, так и в
интерактивном режимах.

В пакетном режиме он обрабатывает стандартный ввод и файлы с
выражениями:

***bc \[файл\]*** ***echo "\[выражение\]" | bc***

Пример:

    $ echo "sqrt(1 + 3)" | bc
    2

При помощи `alias`'ов или определяя функции в `~/.bashrc` можно
выполнять в командной строке простейшие вычисления без явного
вызова bc. Например, определение вот таких функций в `~/.bashrc`:
<code lang="bash">

    function round(){ [ "$2" = "" ] && NUM=3 || NUM=$2; echo $1 | sed "s/\([[:digit:|:digit:]]*\.[[:digit:|:digit:]]\{,$NUM\}\).*/\1/"; }
    function sin(){ echo "scale=10; s($1*a(1)/45);" | bc -l; }
    function cos(){ echo "scale=10; c($1*a(1)/45);" | bc -l; }
    function tan(){ echo "scale=10; arg=$1*a(1)/45; s(arg)/c(arg);" | bc -l; }
    function logn(){ echo "scale=10; l($1);" | bc -l; }
    function log(){ echo "scale=10; l($1)/l(10);" | bc -l; }
    function pow(){ echo "scale=10; $1^$2;" | bc -l; }
    function sqrt(){ echo "scale=10; sqrt($1);" | bc -l; }
    function exp(){ echo "scale=10; e($1);" | bc -l; }
    alias pi="echo 'scale=10; a(1)*4;' | bc -l"
    export pi=$(pi)

</code> позволит быстро считать значения логарифмов, тригонометрических
и степенных функций в командной строке. Например, так: <code lang="C">

    sin 33
    .5446390348

    round 4.12343
    4.123

    pow 2.56 3
    16.777216

</code> (синус 33°, округление числа, возведение в куб числа 2.56).

## Дата и время

### date - выводит текущее время и дату заданным форматом

При запуске без параметров отображает текущую дату, время, день недели,
и временную зону.

Формат вывода может быть задан с помощью спецификаторов, написанных
после знака +. Например:

    date +"%H:%M"

## Планирование заданий

### cron - выполняет команды по расписанию

### at - используется для выполнения команды в заданное время

## Графика и хранители экрана

## Аудио и видео

## Новости Usenet

## Использованные источники

  - [Wikipedia.org](http://wikipedia.org)
  - [Opennet.ru](http://www.opennet.ru)