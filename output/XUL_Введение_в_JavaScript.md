JavaScript - кроссплатформенный язык программирования с динамической
типизацией. Это быстрый встраиваемый язык, используемый не только в
Web, но и в XUL. Здесь он предназначен для динамического управления
внешним видом, общения по сети с другими серверами, и др.
JavaScript похож на С, но значительно гибче его. JavaScript появился в
недрах компании Netscape и использовался в одноимённом браузере.

## Переменные

Переменные в JavaScript объявляются с помощью использования ключевого
слова *var*, либо присвоением значения ранее не объявленной
переменной:

    <nowiki>
    // 1
    var x;

    // 2
    y = 100;
    </nowiki>

Mozilla рекумендует использовать первый вариант. Т.к. JavaScript - язык
с динамической типизацией, то любой переменной мы может присвоить любое
значение:

    <nowiki>
    var x  = 100;
    x = 200.2;
    x = "test";
    </nowiki>

Конечное значение переменной *x* - строка *«test»*.

Попытка использовать необъявленную переменную (за исключением операции
присваивания, как показано вначале) приводит к генерации исключения
*ReferenceError*.

## Константы

Константы - переменные, которые не могут менять своё значение или
переопределяться во время работы скрипта. Например

    <nowiki>
    const a = "some string";
    const b = 100;

    a = 100; // ошибка, "a" не изменится
    </nowiki>

## Значения переменных

Переменные могут хранить несколько типов значений:

  - числовые, включая дробные - *100*, *3.14*;
  - строковые - *"some string"*;
  - булевые - *true* или *false*;
  - *null* - специальное нулевое значение;
  - *undefined* - значение не определено.

Значение *undefined* ведёт себя как *false*, если используется в булевых
операциях. Результатом арифметических операций определённых и не
определённых переменных будет NaN, например

    <nowiki>
    var x; // значение "x" - undefined, не определено

    if(!x)
        x = 100; // x == 100
    </nowiki>

    <nowiki>
    var x; // x == undefined

    var z = x * 100; // z == NaN
    </nowiki>

Значение *null* ведёт себя как *false* и как *0* соответственно в
булевых и численных операциях, например

    <nowiki>
    var x = null;

    if(!x)
        x = 100; // x == 100
    </nowiki>

    <nowiki>
    var x = null;

    var z = x * 2; // z == 0
    </nowiki>

## Литералы

Литералы - значения, используемые в коде прямым текстом, например
*1.24*, *"some string"*. В JavaScript есть несколько типов литералов:

  - массивы
  - булевы
  - дробные числа
  - целые числа
  - объекты
  - строки

Например:

    <nowiki>
    // переменной "x" присвоен массив из трёх чисел - 100, не определено, 200.
    var x = [100, , 200];

    // переменной "x" присвоен литерал "true".
    var x = true;

    // переменной "x" присвоен литерал "200".
    var x = 200;

    // переменной "x" присвоен литерал "3.14".
    var x = 3.14;

    // переменной "x" присвоен литерал "2.2e+10" (другая форма записи дробного числа).
    var x = 2.2e+10;

    // переменной "x" присвоен литерал "hello, world!\n". Escape-последовательности
    // поддерживаются такие же, как и в C.
    var x = "hello, world!\n";

    // переменной "x" присвоен литерал "½#M". Поддерживаются Unicode последовательности
    // "\uXXXX" (XXXX - 16-ричное число), ASCII последовательности "\xXX" (XX - 16-ричное число)
    // и "\XXX" (XXX - 8-ричное число).
    var x = "\u00BD\x23\115";

    // переменной "x" присвоен объектный литерал, теперь "x" ссылается на объект,
    // у которого 3 поля "first", "second" и "third" (аналогично структуре в C).
    var x = { first: 100, second: 2.2, third: "hmm" };

    // пример использования объекта
    var y = x.first; // y теперь равен 100.

    </nowiki>

## Операторы

Операторы в JavaScript в основной массе идентичны таковым в С, за
исключением того, что JavaScript не поддерживает указатели, и
вносит несколько новых операторов (в порядке убывания приоритета):

|                                                                |                                                 |
| -------------------------------------------------------------- | ----------------------------------------------- |
| доступ к члену, создание нового объекта                        | \[\] . new                                      |
| вызов функции                                                  | ()                                              |
| инкремент, декремент                                           | \++ --                                          |
| логическое не, бинарное не, одиночные +/-, тип, void, удаление | \! \~ + - typeof void delete                    |
| умножение, деление, модуль                                     | \* / %                                          |
| сложение, вычитание                                            | \+ -                                            |
| бинарные сдвиги                                                | \<\< \>\> \>\>\>                                |
| отношения, существование, определение                          | \< \<= \> \>= in instanceof                     |
| равенство, тождественное равенство                             | \== \!= === \!==                                |
| бинарное И                                                     | &                                               |
| бинарное ИЛИ-НЕ                                                | ^                                               |
| бинарное ИЛИ                                                   | ǀ                                               |
| логическое И                                                   | &&                                              |
| логическое ИЛИ                                                 | ǁ                                               |
| условие                                                        | ?:                                              |
| присвоение                                                     | \= += -= \*= /= %= \<\<= \>\>= \>\>\>= &= ^= ǀ= |
| запятая                                                        | ,                                               |
|                                                                |                                                 |

Стоит отметить, что

  - тождественное равенство или неравенство учитывает не только значения
    переменных, но и их тип;
  - **new** распределяет память под новый объект указанного типа,
    аналогично C++:

<!-- end list -->

    <nowiki>
    var d = new Date();
    </nowiki>

  - **delete** служит для удаления переменных распределённых с помощью
    new (1), переменных созданных автоматически (2), "своих" свойств
    объектов (3), и элементов массивов (длина массива не меняется)
    (4):

<!-- end list -->

    <nowiki>
    // 1
    var x = new Date();
    delete x;

    // 2
    x = 100;
    delete x;

    // 3
    var x = new Date();
    x.prop = 200;
    delete x.prop; // свойства "prop" больше нет

    // 4a
    var x = new Array(1, 2, 3, 4, 5);
    delete x[0]; // элемента больше нет

    // 4b
    var x = [ 1, 2, 3, 4, 5];
    delete x[0];

    </nowiki>

  - **typeof** возвращает строку с типом объекта:

<!-- end list -->

    <nowiki>
    var x;          // typeof x == "undefined"
    var y = 100;    // typeof y == "number"
    var z = "str";  // typeof z == "string"
    var g = [1, 2]; // typeof g == "object"
    function s() {} // typeof s == "function"
    </nowiki>

  - **instanceof** возвращает *true*, если данный объект является
    объектом данного типа. Иначе возвращает *false*:

<!-- end list -->

    <nowiki>
    var x = [1, 2];

    if(x instanceof Array) // true
        ...
    </nowiki>

  - **in** возвращает *true*, если данное имя свойства или его индекс
    присутствуют в данном объекте:

<!-- end list -->

    <nowiki>
    var x = [1, 2];

    if(0 in x) // true, свойство по индексу 0 есть - число 1
        ...

    if(3 in x) // false, такого индекса нет
        ...

    if("prop" in x) // false, свойства с именем "prop" нет
        ...

    x["prop"] = 100;

    if("prop" in x) // true, свойство с именем "prop" уже есть
        ...

    </nowiki>

## Функции

Для создания функции используется ключевое слово *function*. Функция
одновременно является и объектом. Да, это свойство JavaScript.
Функция - это объект стандартного класса объектов *Function*,
который мы рассмотрим ниже в главе [Предопределённые
объекты](XUL_Введение_в_JavaScript#Предопределённые_объекты).
Функции можно объявлять одну в одной, в таком случае внутренняя функция
видна только внутри той функции, в которой она объявлена. Внутри
функции можно создавать переменные, которые не видны за пределами
данной функции (кроме свойств, задействуя дуальную природу функций), и
прячут глобальные переменные. Параметры передаются в скобках через
запятую, без указания типа. Функция может возвращать значение с
помощью ключевого слова *return \[литерал или переменная\]*.
Например:

    <nowiki>
    // объявление функции f с аргументами a и b
    function f(a, b)
    {
        // тело функции
        ...
    }
    </nowiki>

    <nowiki>
    var a = 100;

    function f()
    {
        a = 200;
    }

    // a == 200, использовалась глобальная переменная "a"
    </nowiki>

    <nowiki>
    var a = 100;

    // аргумент функции "a" прячет глобальный идентификатор "a",
    // поэтому внутри этой функции мы будем работать с аргументом, а не
    // с глобальной переменной
    function f(a)
    {
        a = 200;
    }

    var z;
    f(z);

    // a == 100, глобальная переменная не поменялась
    </nowiki>

    <nowiki>
    function f()
    {
        // внутренняя функция
        function func() { return 100; }

        var a = func(); // a == 100, использовалась внутренняя функция "func()"
    }

    // x == undefined, внутренняя функция "func()" не видна
    // за пределами "f"
    var x = typeof(func);
    </nowiki>

    <nowiki>
    // функция, возвращающая число 100
    function f()
    {
        return 100;
    }

    function f2()
    {
        return; // аналогично как в void функции в С
    }

    var x = f(); // x == 100

    x = f(); // x == undefined т.к. функция ничего не вернула
    </nowiki>

Параметры примитивных типов передаются по значению, сложных (объекты) -
по значению ссылки (как в Java). Это значит, что если функция принимает
сложный объект как параметр, она сможет менять его свойства, но не сам
объект. Такое поведение сходно с поведением функции в С, которая
принимает на вход указатель. Например:

    <nowiki>
    #include <stdio.h>
    #include <stdlib.h>

    struct S
    {
        int a;
    };

    void f(struct S *s)
    {
        struct S *s2 = (struct S *)malloc(sizeof(struct S));
        s2->a = 200;

        // пробуем переустановить поле
        s->a = 100;

        // пробуем переустановить сам указатель
        s = s2;
    }

    int main(int argc, char **argv)
    {
        struct S *s = (struct S *)malloc(sizeof(struct S));

        f(s);

        // "s" не поменялся, но память утекла :-)
        // s->a == 100
        printf("%d\n", s->a);

        return 0;
    }
    </nowiki>

Аналогично и в JavaScript:

    <nowiki>
    function f(obj)
    {
        // поменяем свойство объекта
        obj.prop = "another";

        // попробуем поменять сам объект
        obj = { first: "hello" };
    }

    var x = { prop: "other" };

    f(x);

    // теперь
    // x.prop == "another"
    // x.first == undefined

    </nowiki>

Функции можно создавать по условию:

    <nowiki>
    if(false)
    {
        function f()
        {
            alert("hello");
        }
    }

    alert(typeof f); // "undefined"
    </nowiki>

    <nowiki>
    if(true)
    {
        function f()
        {
            alert("hello");
        }
    }

    alert(typeof f); // "function"
    </nowiki>

И даже присваивать переменным:

    <nowiki>
    var x = function() { alert("hello");  }

    x();
    </nowiki>

Можно передавать в качестве аргументов в другие функции:

    <nowiki>
    function a(obj)
    {
        var x = obj(); // подразумеваем, что obj - функция

        return x;
    }

    function f()
    {
        return 100;
    }

    var y = a(f); // y == 100
    var z = a( function() { return 200; } ); // z == 200
    </nowiki>

Возвращать из других функций:

    <nowiki>
    function f()
    {
        return function() { return 300; };
    }

    var x = f()(); // x == 300
    </nowiki>

И даже использовать в качестве прототипов объектов с поддержкой
замыканий:

    <nowiki>
    function a()
    {
        this.x = 200;

        this.returnsomething = function() { return 100; }
    }

    var x = new a();
    var y = x.returnsomething();

    // x.x == 200
    // y == 100
    </nowiki>

Неплохо, верно? :-)

## Предопределённые функции

  - **escape(str)**

Возвращает Unicode строку, в которой все символы **не** из латинского
алфавита и набора *\* @ - _ + . /* заменены на *%XX* (например
пробел - %20), а все символы выше ASCII - на Unicode представление
вида *%uXXXX*. Например:

escape("Hello world"); // вернёт "Hello%20world" escape("hello \#%"); //
"hello%20%23%25" escape("hello½"); // "hello%BD" escape("hello☺"); //
"hello%u263A"

Не рекомендуется использовать эту функцию для кодирования URI,
используйте encodeURI().

  - **unescape(str)**

Проделывает обратные операции - заменяет все специальные
последовательности символов на реальные символы.

  - **encodeURI(str)**

Кодирует URI. Не кодирует символы *: / ; ?*, которые можно закодировать
с помощью encodeURIComponent(). Например:

    <nowiki>
    encodeURI("http://хеллоу.com"); // "http://%D1%85%D0%B5%D0%BB%D0%BB%D0%BE%D1%83.com"
    encodeURI("http://hello world.com"); // "http://hello%20world.com"
    </nowiki>

  - **decodeURI(str)**

Проделывает обратные операции.

  - **encodeURIComponent(str)**

Кодирует URI, включая символы *: / ; ?*, а это значит что URI,
содержащий несколько компонент (/dir1/dir2/index.html), станет
нечитаем веб-сервером. В таком случае пользуйтесь encodeURI.

  - **decodeURIComponent(str)**

Проделывает обратные операции.

  - **isFinite(num)**

Проверка на конечность числа:

    <nowiki>
    if(isFinite(x))
    ...
    </nowiki>

  - **isNaN(num)**

Проверка на NaN (не-число) значение:

    <nowiki>
    if(isNaN(x))
    ...
    </nowiki>

  - **parseInt(str \[, radix\])**

Конвертация строки, содержащей число, в число:

    <nowiki>
    var x = parseInt("0xFF", 16); // x == 255
    </nowiki>

  - **parseFloat(str)**

Конвертация строки, содержащей дробное число, в число:

    <nowiki>
    var x = parseFloat("2.24355e+2"); // x == 224.355
    var y = parseFloat("100"); // y == 100
    </nowiki>

  - **String(obj)**

Конвертация объекта в строку, использует метод toString() в объекте:

    <nowiki>
    var d = new Date();
    var x = String(d); // "Thu Sep 18 2008 21:56:44 GMT+0300 (EET)"

    var d2 = { some: "string in object", toString: function() { return "" + this.some; } };
    var x2 = String(d); // "string in object"
    </nowiki>

  - **Number(obj)**

<!-- end list -->

  - **eval()**

Есть также несколько очень полезных методов в объекте *window*:

  - **dump**

Вывод в шелл сообщения. Может быть полезно при отладке. Например:

    <nowiki>
    var x = 1;
    ...
    dump("Value of x: " + x + "\n");
    </nowiki>

  - **alert**

Показывает визуальное сообщение (message box). Например:

    <nowiki>
    var x = 1;
    ...
    alert("Value of x: " + x);
    </nowiki>

## Объекты

Объекты - это некие сложные сущности, хранящие свойства. Свойством может
быть число, строка, метод и т.д. Это аналогично объектам в C++ или С. С
объектами связано понятие прототипа. Прототип - это объект, хранящий
свойства и методы для объекта внутри которого он объявлен, наподобие
определения класса в C++. При создании новых объектов с помощю *new*,
все эти объекты будут иметь свойства, определённые в прототипе. Уже
созданные объекты с помощью *new* (до изменения прототипа) также
будут иметь новые свойства, определённые в прототипе. К прототипу
обращаются через имя базового объекта (*Object*, *Date*, и т.д.) и
слова "prototype". Можно дописывать прототип своих и
предопределённых объектов. Например:

    <nowiki>

    // объект x создали до изменения прототипа
    var x = new Date();

    // добавляем в стандартный объект Date свой метод
    Date.prototype.mymethod = function()
    {
        return 100;
    }

    // добавляем в стандартный объект Date своё числовое свойство
    Date.prototype.X = 255;

    // объект y создали после изменения прототипа
    var y = new Date();

    var z1 = x.mymethod(); // z1 == 100
    var z2 = y.mymethod(); // z2 == 100

    var z3 = x.X; // z3 == 255
    var z4 = y.X; // z4 == 255
    </nowiki>

Для своих классов объектов можно полностью перезаписывать прототип,
например, как показано в следующей главе с классом объектов Shop.
Используем пример попроще:

    <nowiki>
    // базовый объект, с пустым телом
    function Shop() {}

    // полностью перезаписали прототип на свой объект, который суть
    // есть объект-инициализатор, которые мы рассмотрим ниже
    // в пункте "прямая инициализация"
    Shop.prototype =
    {
        // все объекты класса Shop будут иметь этот метод
        method: function(which)
        {
            return 100;
        }
    }

    var o1 = new Shop();
    var o2 = new Shop();

    var z1 = o1.method(); // z1 == 100
    var z2 = o2.method(); // z2 == 100
    </nowiki>

Рассмотрим несколько способов создания объектов:

  - прямая инициализация

Мы уже рассматривали такой способ выше. В фигурных скобках через запятую
создаются пары *имя_свойства*:*значение_свойства* (т.н. объектный
литерал, литерал-объект, object literal):

    <nowiki>
    // создали объект
    var x = { some: "string in object", toString: function() { return this.some; } };

    // вызвали его метод
    var s = x.toString();
    </nowiki>

  - с помощью функции-прототипа и операции *new*

Мы уже рассматривали такой способ выше.

Отметим лишь, что объект объявленный через *{}* а не через *function* не
может служить классом объектов, т.е. нельзя создать другие такие же
объекты с помощью операции *new*:

    <nowiki>
    function a(X)
    {
        // создаём новые свойства через "this" ссылку,
        // к которым можно будет обращаться после создания объекта
        this.x = X;

        this.returnsomething = function() { return 100; }
    }

    // новый объект
    var x = new a(10);
    var y = x.returnsomething();

    // x.x == 10
    // y == 100

    var z = x.x + y; // z == 110

    var O = {};
    var x = new O(); // исключение "TypeError: O is not a constructor"
    </nowiki>

  - медленная инициализация

Основана на свойстве JavaScript создавать свойства по мере обращения к
ним на запись:

    <nowiki>
    var z = {}; // пустой объект

    // создали свойство "value" со значением "200"
    z.value = 200;

    // создали свойство-метод, который возвращает свойство "value"
    z.getValue = function() { return this.value; }

    var y = z.getValue(); // y == 200

    </nowiki>

Заметим, что внедрять таким образом свои свойства можно в любые объекты.

Вы уже заметили, что мы несколько раз использовали ключевое слово
*this*. Это ссылка на текущий объект, в котором используется *this*,
аналогично как в C++ или Java. По этой ссылке можно получать доступ
к свойствам объекта из контекста самого объекта, например из вызываемой
функции *getValue()*. За пределами всех объектов *this* ссылается на
глобальный объект окна.

К свойству можно обращаться двумя способами:

  - напрямую по имени

<!-- end list -->

    <nowiki>
    var a = {};
    a.x = 100;
    var z = a.x; // z == 100
    </nowiki>

  - как к члену массива свойств, по имени

<!-- end list -->

    <nowiki>
    var a = {};
    a.x = 100;
    var z = a["x"]; // z == 100
    </nowiki>

## Предопределённые объекты

### Object (базовый объект)

Object представляет собой базовый объект. Все стандартные объекты
(*Date*, *Math*, и т.д.) наследуются от него. Экземпляры базового
объекта можно создавать с помощью *new* или инициализатором, как
показано выше. Например:

    <nowiki>
    var o = {}; // инициализатор, typeof(o) == object
    var o2 = new Object(); // typeof(o2) == object
    </nowiki>

Методы:

  - **hasOwnProperty** - определяет, является ли аргумент прямым
    свойством объекта

Наследованные свойства, или свойства находящиеся в прототипе, не
являются прямыми свойствами данного объекта. Например:

    <nowiki>
    function Shop()
    {
        this.d = "direct property";
    }

    Shop.prototype =
    {
        things: [ "dvd", "cd" ],

        sell: function(which)
        {
            return this.things.indexOf(which) >= 0;
        },

        toString: function()
        {
            return "We have " + this.things;
        }
    }

    var x = new Shop();

    var y = x.hasOwnProperty("things"); // false, т.к. things - свойства из прототипа
    var z = x.hasOwnProperty("d"); // true, прямое свойство

    </nowiki>

  - **isPrototypeOf** - определяет, является ли один объект прототипом
    другого

Объект *Shop* возьмём из прошлого пункта.

    <nowiki>
    var x = new Shop(); // объект Shop
    var y = {}; // обычный объект

    function MegaShop() {} // другой магазин

    MegaShop.prototype = new Shop(); // наследник Shop

    var z = new MegaShop();

    var b1 = Shop.prototype.isPrototypeOf(x); // true, прототип x - это прототип Shop
    var b2 = Shop.prototype.isPrototypeOf(y); // false, прототип y - не прототип Shop
    var b3 = Shop.prototype.isPrototypeOf(z); // true, прототип z - прототип Shop
    </nowiki>

  - **propertyIsEnumerable** - определяет, является ли свойство
    перечислимым

Если свойство не перечислимо, оно не будет появляться в операциях
перечисления свойст объекта, например с помощью *for(i in obj)*.
Свойства объявленные в прототипе не перечислимы.

    <nowiki>
    var x = new Shop();

    var b1 = x.propertyIsEnumerable("things"); // false, things - свойство прототипа
    var b2 = x.propertyIsEnumerable("toString"); // false, toString - наследованое свойство
    var b3 = x.propertyIsEnumerable("d"); // true, d - прямое свойство
    </nowiki>

  - **toString** - возвращает объект как строку

Это важный метод, преобразующий объект в строку там, где подразумеваются
операции со строками. Можно (и скорее всего нужно) переопределить
*toString* для своих классов объектов. По умолчанию возвращает строку
«*\[object Object\]*». Стандартные объекты (*Date*, *Number*, и т.д.)
переопределяют этот метод. *toString* уже определён в нашем объекте
*Shop*. Например:

    <nowiki>
    var x = new Shop();

    // dump принимает строку как аргумент,
    // результатом операции "+" будет строка "We have dvd,cd".
    //
    // JavaScript при сложении фактически выполнит
    // x.toString() + "\n". Важно, что при вызове нашего метода toString (где происходит
    // сложение строки "We have " и массива things), JavaScript также преобразует
    // встроенный массив things в строку.
    dump(x + "\n");
    </nowiki>

  - **valueOf** - возвращает примитивное хранимое значение

Используется редко. Можно (и скорее всего нужно) переопределить
*valueOf* для своих классов объектов.

### Array (массив)

Представляет собой массив. В качестве конструктора принимает ноль или
более элементов:

    <nowiki>
    var x = new Array(); // пустой массив
    var y = new Array(100, 200, "string"); // 3 элемента - 2 числа и строка
    var z = [1, 2, 3]; // также объект Array

    var z1 = y[0]; // z1 == 100
    var z2 = y[2]; // z2 == "string"
    </nowiki>

К элементам массива можно обращаться (как на чтение, так и на запись)
через оператор доступа \[\]. Индексация элементов, также как и в С,
начинается с 0.

Массив имеет свойство *length*, которое доступно на чтение и запись.
Массив может динамически менять сой размер при записи несуществующих
элементов через оператор доступа *\[\]*, или через запись значения в
свойство *length*. Важно помнить, что массив не может быть дырявым,
т.е. он всегда имеет *length-1* элементов, некоторые из которых могут
быть не определены (*undefined*, несуществующие элементы). Например:

    <nowiki>
    var x = new Array(); // пустой массив
    x[30] = 100;

    // z == 31, 30 undefined элементов и 1 число
    var z = x.length;
    </nowiki>

Методы:

  - **concat** - объединение

Можно объединять массив со списком значений, либо с другим массивом:

    <nowiki>
    var x = new Array();
    var y = new Array(100, 200, "string");

    var z = x.concat(y); // z == [ "1", 100, 200, "string" ]
    </nowiki>

  - **join** - объединение в строку

Объединяет элементы массива в строку, принимая разделитель элементов в
строке как аргумент. Разделитель по умолчанию - *", "*:

    <nowiki>
    var y = new Array(100, 200, "string");

    var z = y.join(", "); // z == "100, 200, string"
    </nowiki>

  - **pop** - удаляет и возвращает последний элемент

<!-- end list -->

    <nowiki>
    var y = new Array(100, 200, "string");
    var z = y.pop(); // z == "string", размер массива == 2 элемента
    </nowiki>

  - **push** - вставляет элемент в конец, возвращает длину массива

<!-- end list -->

    <nowiki>
    var y = new Array(100, 200, "string");
    var z = y.push("string2"); // z == 4, размер массива == 4 элемента
    </nowiki>

  - **reverse** - обращает следование элементов

<!-- end list -->

    <nowiki>
    var y = new Array(100, 200, "string");
    y.reverse(); // y == [ "string", 200, 100 ]
    </nowiki>

  - **shift** - удаляет и возвращает первый элемент

<!-- end list -->

    <nowiki>
    var y = new Array(100, 200, "string");
    var z = y.shift(); // z == 100, размер массива == 2 элемента
    </nowiki>

  - **slice** - возвращает секцию

Возвращает секцию массива, основываясь на переданных индексах. Первый
индекс - индекс начала, второй - до которого производить выборку (не
включительно):

    <nowiki>
    var y = new Array(100, 200, "string");
    var z = y.slice(1,3); // z == [ 200, "string" ]
    </nowiki>

  - **splice** - вставляет элементы, с возможностью удаления

Splice позволяет вставлять элементы и удалять из этого же места
элементы. Первый аргумент - индекс, с которого начинать. Второй
аргумент - количество элементов, которое нужно удалить. Далее следуют
элементы, которые нужно вставить.

    <nowiki>
    var y = new Array(100, 200, 300, "string");

    y.splice(1, 0, "hehe", "str"); // y == [ 100, "hehe", "str", 200, 300, "string" ]

    y.splice(1, 2, "hehe2", "str2");  // y == [ 100, "hehe2", "str2", 200, 300, "string" ]
    </nowiki>

  - **sort** - сортировка массива

Сортирует массив, может также принимать на вход функцию, которой будет
пользоваться для сравнения. Функция сравнения должна возвращать -1,
если первый аргумент меньше второго, 1 если больше, и 0 если они
равны. Важно, что по умолчанию элементы сравниваются в строковом
виде. Например:

    <nowiki>
    var y = new Array(11, 2, 3, 4, 10, 0);
    y.sort(); // y == [ 0, 10, 11, 2, 3, 4 ], странновато отсортировано

    y = new Array(11, 2, 3, 4, 10, 0);

    // используем прямое сравнение, т.к. мы знаем, что наши аргументы - числа,
    // на выходе получаем нормально отсортированный массив
    y.sort(
    function(a, b)
    {
        if(a < b) return -1;
        if(a > b) return 1;
        if(a  == b) return 0;
    });

    // y == [ 0, 2, 3, 4, 10, 11 ], отсортировано нормально

    </nowiki>

  - **unshift** - втавляет элементы в начало, возвращает длину массива

<!-- end list -->

    <nowiki>
    var y = new Array(100, 200);
    var z = y.unshift(400, 500); // z == 4, y == [ 400, 500, 100, 200 ]
    </nowiki>

### Date (дата)

Представляет собой дату. В качестве конструктора может принимать разные
элементы:

    <nowiki>
    var d;

    d = new Date(); // текущая дата
    d = new Date("September 19, 2008 00:30:00"); // из строки
    d = new Date(2008, 11, 19); // год, месяц (начиная с нуля), день
    d = new Date(2008, 11, 19, 0, 30, 0); // год, месяц, день, час, минуты, секунды
    </nowiki>

Методы:

  - **getTime** - возвращает количество миллисекунд с начала эпохи

<!-- end list -->

    <nowiki>
    d = new Date(2008, 11, 19, 0, 30, 0);
    var z = d.getTime(); // z == 1229639400000
    </nowiki>

  - **getFullYear** - возвращает полный год

<!-- end list -->

    <nowiki>
    d = new Date(2008, 11, 19, 0, 30, 0);
    var z = d.getFullYear(); // z == 2008
    </nowiki>

  - **getYear** - возвращает год, начиная с 1900

<!-- end list -->

    <nowiki>
    d = new Date(2008, 11, 19, 0, 30, 0);
    var z = d.getYear(); // z == 108
    </nowiki>

  - **getMonth** - возвращает номер месяца

<!-- end list -->

    <nowiki>
    d = new Date(2008, 11, 19, 0, 30, 0);
    var z = d.getMonth(); // z == 11
    </nowiki>

  - **getDay** - возвращает день недели

<!-- end list -->

    <nowiki>
    d = new Date(2008, 11, 19, 0, 30, 0);
    var z = d.getDay(); // z == 5
    </nowiki>

  - **getDate** - возвращает день месяца

<!-- end list -->

    <nowiki>
    d = new Date(2008, 11, 19, 0, 30, 0);
    var z = d.getDate(); // z == 19
    </nowiki>

  - **getHours** - возвращает часы

<!-- end list -->

    <nowiki>
    d = new Date(2008, 11, 19, 0, 30, 0);
    var z = d.getHours(); // z == 0
    </nowiki>

  - **getMinutes** - возвращает минуты

<!-- end list -->

    <nowiki>
    d = new Date(2008, 11, 19, 0, 30, 0);
    var z = d.getMinutes(); // z == 30
    </nowiki>

  - **getSeconds** - возвращает секунды

<!-- end list -->

    <nowiki>
    d = new Date(2008, 11, 19, 0, 30, 25);
    var z = d.getSeconds(); // z == 25
    </nowiki>

  - **getMilliseconds** - возвращает миллисекунды

<!-- end list -->

    <nowiki>
    d = new Date(2008, 11, 19, 0, 30, 25);
    var z = d.getMilliseconds(); // z == 0
    </nowiki>

  - **getTimezoneOffset** - возвращает смещение по GMT

<!-- end list -->

    <nowiki>
    d = new Date(); // текущее локальное время и дата
    var z = d.getTimezoneOffset(); // z == -180 (GMT+03, Беларусь)
    </nowiki>

  - набор аналогичных методов, но для UTC зоны:
    1.  **getUTCFullYear** - возвращает полный год
    2.  **getUTCMonth** - возвращает год, начиная с 1900
    3.  **getUTCDate** - возвращает день месяца
    4.  **getUTCDay** - возвращает день недели
    5.  **getUTCHours** - возвращает часы
    6.  **getUTCMinutes** - возвращает минуты
    7.  **getUTCSeconds** - возвращает секунды
    8.  **getUTCMilliseconds** - возвращает миллисекунды

<!-- end list -->

  - набор методов для установки времени:
    1.  **setFullYear(year, \[month\], \[day\])**
    2.  **setYear(year)**
    3.  **setMonth(month, \[day\])**
    4.  **setDate(day_of_month)**
    5.  **setHours(hours, \[minutes\], \[seconds\], \[millisec\])**
    6.  **setMinutes(minutes, \[seconds\], \[millisec\])**
    7.  **setSeconds(seconds, \[millisec\])**
    8.  **setMilliseconds(milli)**
    9.  **setTime(milli)**

<!-- end list -->

  - набор методов для установки времени, для UTC зоны
    1.  **setUTCFullYear(year, \[month\], \[day\])**
    2.  **setUTCMonth(month, \[day\])**
    3.  **setUTCDate(day_of_month)**
    4.  **setUTCHours(hours, \[minutes\], \[seconds\], \[millisec\])**
    5.  **setUTCMinutes(minutes, \[seconds\], \[millisec\])**
    6.  **setUTCSeconds(seconds, \[millisec\])**
    7.  **setUTCMilliseconds(milli)**

<!-- end list -->

  - **toLocaleString** - возвращает дату и время в виде строки, в
    текущей локали

<!-- end list -->

    <nowiki>
    d = new Date();
    var z = d.toLocaleString(); // z == "Птн 19 Сен 2008 00:20:40"
    </nowiki>

  - **toLocaleDateString** - возвращает дату в виде строки, в текущей
    локали

<!-- end list -->

    <nowiki>
    d = new Date();
    var z = d.toLocaleDateString(); // z == "19.09.2008"
    </nowiki>

  - **toLocaleTimeString** - возвращает время в виде строки, в текущей
    локали

<!-- end list -->

    <nowiki>
    d = new Date();
    var z = d.toLocaleTimeString(); // z == "00:22:08"
    </nowiki>

  - **toString** - возвращает полное описание даты, включая GMT смещение

<!-- end list -->

    <nowiki>
    d = new Date();
    var z = d.toString(); // z == "Fri Sep 19 2008 00:22:38 GMT+0300 (EET)"
    </nowiki>

  - **toUTCString** - возвращает полное описание даты для UTC зоны

<!-- end list -->

    <nowiki>
    d = new Date();
    var z = d.toUTCString(); // z == "Thu, 18 Sep 2008 21:27:29 GMT"
    </nowiki>

  - **parse** - возвращает количество миллисекунд для даты из строки

<!-- end list -->

    <nowiki>
    d = new Date();
    var z = Date.parse("Sep 19, 2008"); // z == 1221771600000
    </nowiki>

  - **valueOf** - аналогично getTime

### Function (функция)

Объект *Function* предназначен для создания функций во время выполнения.
В качестве аргументов получает список параметров (каждый параметр в виде
строки с идентификатором), и последним аргументом - строку с JavaScript
кодом. Использование:

    <nowiki>
    var x = new Function ("a", "b", "c", "return (a + b + c);");

    var z = x("hello", ", ", "world"); // z == "hello, world"
    </nowiki>

### Math (математика)

Объект *Math* содержит различные математические методы и константы.
*Math* не имеет конструктора, поэтому его методы можно использовать
только напрямую, через префикс *Math*.

Методы:

  - **abs** - возвращает абсолютное значение

<!-- end list -->

    <nowiki>
    var x = Math.abs(-1.1); // x == 1.1
    </nowiki>

  - **sin, cos, tan** - тригонометрические функции, аргумент - радианы

<!-- end list -->

    <nowiki>
    var x = Math.sin(1); // x == 0.8414709848078965
    </nowiki>

  - **acos, asin, atan, atan2** - обратные тригонометрические функции

<!-- end list -->

    <nowiki>
    var x = Math.asin(0.8414709848078965); // x == 1
    </nowiki>

  - **exp, log** - экспоненциальный и натуральный логарифм

<!-- end list -->

    <nowiki>
    var x = Math.log(2.718281828459045); // x == 1
    </nowiki>

  - **ceil** - округляет в большую сторону

<!-- end list -->

    <nowiki>
    var x = Math.ceil(2.7); // x == 3
    </nowiki>

  - **floor** - округляет в меньшую сторону

<!-- end list -->

    <nowiki>
    var x = Math.floor(2.7); // x == 2
    </nowiki>

  - **min, max** - возвращает минимум и максимум

<!-- end list -->

    <nowiki>
    var x = Math.min(-3, 10); // x == -3
    </nowiki>

  - **pow** - возведение в степень

<!-- end list -->

    <nowiki>
    var x = Math.pow(10, 2); // x == 100
    </nowiki>

  - **random** - возвращает случайное число от 0 до 1

<!-- end list -->

    <nowiki>
    var x = Math.random(); // x == 0.577903639379265
    var y = Math.random(); // y == 0.9858962869730497
    </nowiki>

  - **round** - округление к ближайшему целому

<!-- end list -->

    <nowiki>
    var x = Math.round(2.99); // x == 3
    </nowiki>

  - **sqrt** - возвращает квадратный корень числа

<!-- end list -->

    <nowiki>
    var x = Math.sqrt(25); // x == 5
    </nowiki>

Константы:

  - **Math.E** - число Эйлера, т.н. *e*
  - **Math.LN2** - натуральный логарифм из 2
  - **Math.LN10** - натуральный логарифм из 10
  - **Math.LOG2E** логарифм по основанию 2 из e
  - **Math.LOG10E** - десятичный логарифм из *e*
  - **Math.PI** - число Пи
  - **Math.SQRT1_2** - квадратный корень из 1/2
  - **Math.SQRT2** - квадратный корень из 2

### Number (число)

Объект *Number* содержит различные методы для операций с числом и
константы. Имеет конструктор.

Методы:

  - **toExponential** - возвращает строку с записанным числом в
    экспоненциальном виде

<!-- end list -->

    <nowiki>
    var z = new Number(2200);
    var x = z.toExponential(); // x == "2.200e+3"
    </nowiki>

  - **toFixed** - возвращает строку с записанным числом в фиксированном
    виде

<!-- end list -->

    <nowiki>
    var z = new Number(2.200e+3);
    var x = z.toFixed(); // x == "2200"
    </nowiki>

  - **toPrecision** Returns a string representing the number to a
    specified precision in fixed-point notation.
  - **toSource** - возвращает строку с кодом, создающую данный объект

<!-- end list -->

    <nowiki>
    var z = new Number(2.5);
    var x = z.toSource();

    var y = eval(x); // y == 2.5
    </nowiki>

  - **toString** - объект в виде строки

<!-- end list -->

    <nowiki>
    var z = new Number(2.5);
    var x = z.toString(); // x == "2.5"
    </nowiki>

  - **valueOf**

Константы:

  - *'Number.MAX_VALUE* - максимально возможное значение
  - **Number.MIN_VALUE** - минимально возможное значение
  - **Number.NaN** - значение для представления *не-числа*
  - **Number.NEGATIVE_INFINITY** - отрицательная бесконечность
  - **Number.POSITIVE_INFINITY** - положительная бесконечность

### RegExp (ругулярные выражения)

### String (строка)

Объект *String* представляет строку. Имеет конструктор. Объект *String*
это не тоже самое, что строковый литерал, но JavaScript позволяет
использовать строковые литералы как объекты. Например:

    <nowiki>
    // JavaScript автоматически преобразует строковый литерал во временный объект
    // String, и выполнит запрошенный метод
    var y = "Hello".toLowerCase(); // y == "hello"
    </nowiki>

Методы:

  - '''anchor ''' - возвращает html ссылку, аргумент - атрибут ссылки
    "name"

<!-- end list -->

    <nowiki>
    var x = new String("hello");
    var y = x.anchor("http://hello.com"); // y == "<a name="http://hello.com">hello</a>"
    </nowiki>

  - **big, blink, bold, fixed, italics, small, strike, sub, sup** - html
    форматирование строки

<!-- end list -->

    <nowiki>
    var x = new String("hello");
    var y = x.big(); // y == "<big>hello</big>"
    var z = x.bold(); // z == "<b>hello</b>"
    </nowiki>

  - **charAt, charCodeAt** - возвращают символ и код символа по позиции
    в строке

<!-- end list -->

    <nowiki>
    var x = new String("hello");
    var y = x.charAt(2); // y == "l"
    var z = x.charCodeAt(); // z == 104 (символ 'l')
    </nowiki>

  - **indexOf, lastIndexOf** - возвращают позицию подстроки, и последнюю
    позицию подстроки

<!-- end list -->

    <nowiki>
    var x = new String("hello");
    var y = x.indexOf("l"); // y == 2
    var z = x.lastIndexOf("l"); // z == 3
    </nowiki>

  - **link** - возвращает html ссылку, аргумент - атрибут ссылки "href"

<!-- end list -->

    <nowiki>
    var x = new String("hello");
    var y = x.link("http://hello.com"); // y == "<a href="http://hello.com">hello</a>"
    </nowiki>

  - **concat** - возвращает объединение двух строк

<!-- end list -->

    <nowiki>
    var x = new String("hello, ");
    var y = x.concat("http://hello.com"); // y == "hello, http://hello.com"
    </nowiki>

  - **fromCharCode** - возвращает строку, составленную из переданных
    кодов символов

Этот метод должен вызываться напрямую через объект *String*:

    <nowiki>
    var x = String.fromCharCode(0x2639, 0x263a); // x == "☹☺"
    </nowiki>

  - **split** - возвращает массив строк, полученный из разделённой на
    части строки

Аргументы - строка-разделитель (или регулярное выражение), и
максимальное количество обработанных элементов.

    <nowiki>
    var x = new String("1, 2, 3, 4");

    // "," - разделитель, число 2 - находим максимум 2 элемента
    var y = x.split(",", 2); // y == [ "1", "2" ]
    </nowiki>

    <nowiki>
    var x = new String("");
    var y = x.split(","); // y = [ "" ]
    </nowiki>

  - **slice** - возвращает подстроку между указанными индексами

<!-- end list -->

    <nowiki>
    var x = new String("hello, world");
    var y = x.slice(5, 8); // y == ", w"
    var z = x.slice(5); // z == ", world"
    </nowiki>

  - **substring, substr** - возвращают подстроки

<!-- end list -->

    <nowiki>
    var x = new String("hello, world");

    // подстрока между первым индексом и вторым
    var y = x.substring(7, 10); // y == "wor"

    // подстрока от индекса, с указанной длиной подстроки
    var z = x.substr(0, 4); // z == "hell"
    </nowiki>

  - **match, replace, search** - поиск и замена подстрок, опираясь на
    регулярные выражения

<!-- end list -->

    <nowiki>
    var x = new String("hello, world");

    // поиск регулярного выражения "o.", что значит "символ o и любой другой символ за ним",
    // возвращает массив найденных совпадений, в данном случае - 2 совпадения
    var y = x.match(/o./g); // y == [ "o,", "or" ]
    </nowiki>

    <nowiki>
    var x = new String("hello, world");

    // поиск и замена на,строку "!"
    var y = x.replace(/o./g, "!"); // y == "hell! w!ld"
    </nowiki>

    <nowiki>
    var x = new String("hello, world");

    // поиск и замена используя функцию, принимающую как аргумент найденное совпадение
    // и возвращающую строку
    var y = x.replace(/o./g, function(a) { return a + "!"; }); // y == "hello,! wor!ld"
    </nowiki>

    <nowiki>
    var x = new String("hello, world");

    // поиск регулярного выражения, возвращает найденный индекс, или -1
    var y = x.search(/o./); // y == 4
    </nowiki>

  - **toLowerCase, toUpperCase** - возвращают строки в нижнем и верхнем
    регистрах

<!-- end list -->

    <nowiki>
    var x = new String("Hello, World");
    var y = x.toLowerCase(); // y == "hello, world"
    var z = x.toUpperCase(); // z == "HELLO, WORLD"
    </nowiki>

## Вставка в XUL документ

Вставить код JavaScript в XUL документ можно двумя способами:

  - прямой вставкой

В этом случае мы обрамляем JavaScript код элементом *script*:

    <nowiki>
    <?xml version="1.0"?>
    <?xml-stylesheet href="chrome://global/skin/" type="text/css"?>

    <window
        title="Example"
        width="320" height="200"
        ns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

    <script type="application/x-javascript">

    function func()
    {
        alert("Hello");
    }

    addEventListener("load", func, false);

    </script>

    </window>
    </nowiki>

Надо помнить, что в этом случае XML парсер нашего документа сочтёт,
например, операторы *\>* и *\<*, элементами XML разметки. В этом
случае надо использовать специальную XML секцию *CDATA*, внутри
которой и пишется код. Например:

    <nowiki>
    <script type="application/x-javascript">

    <![CDATA[

    function func()
    {
        var x = 0;

        // сложный момент для XML парсера, но мы предупредили его
        // с помощью секции CDATA
        if(x < 0)
            alert("Hello");
    }

    addEventListener("load", func, false);

    ]]>

    </script>
    </nowiki>

  - внешней вставкой

Аналогично с помощью элемента *script* и атрибута *src* вставляем
JavaScript код из внешнего файла:

    <nowiki>
    <?xml version="1.0"?>
    <?xml-stylesheet href="chrome://global/skin/" type="text/css"?>

    <window
        title="Example"
        width="320"
        height="200"
        ns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

    <script type="application/x-javascript" src="example.js" />

    </window>
    </nowiki>

Где файл *example.js* лежит в этом же каталоге, где и XUL документ.
Можно указывать относительные пути, и *<chrome://>* пути.

## Ссылки

  - [1](http://developer.mozilla.org/en/JavaScript)
  - [2](http://www.javascriptkit.com)
  - [3](http://www.getfirebug.com)
  - [4](http://xml.com/axml/target.html#sec-cdata-sect)

[Category:XUL](Category:XUL)