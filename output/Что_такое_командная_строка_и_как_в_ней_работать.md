Многие начинающие пользователи GNU/Linux, переходящие с других
операционных систем могут не знать, что такое «консоль»,
«терминал», «shell» и так далее. Однако, к сожалению, с очень
большой вероятностью при работе в Linux вам придется
воспользоваться консолью. Хотя производители
дистрибутивов Linux стремятся избавить пользователей от
необходимости использования консоли вообще, пока что никому не
удавалось полностью решить эту задачу. Кроме того, если вы будете
обращаться за помощью к другим пользователям, они могут не знать, какой
у вас дистрибутив и как пользоваться его средствами для диагностики
вашей проблемы, и предложат вам выполнить какие-либо команды (общие
для всех дистрибутивов) и представить результат их выполнения.

Конечно, быть «гуру» написания скриптов совершенно необязательно. Даже
знать наизусть основные команды необязательно. Но в ответ на
«Приведите вывод *cat /proc/scsi/scsi*» отвечать «А что это
такое, где это вводить?» не следует: многие пользователи не захотят
после этого тратить на вас время.

**Цели этой статьи таковы:**

1.  Объяснить, что такое «консоль», как ее запустить и как вводить туда
    команды.
2.  Объяснить, как устроены команды и как получить информацию по
    отдельным командам.
3.  Объяснить, почему команду **sudo rm -rf /\*** вводить не следует.

## Что такое «консоль»

Не будем углубляться в историю и скажем просто: в данной статье под
консолью (она же *«терминал»*, *«shell»*) понимается программное
обеспечение, реализующее общение с компьютером при помощи текстовых
команд (*Command-line interface*, *CLI*). Аналог в Windows: *cmd*.
Понятие **виртуальная консоль** вводится отдельно.

В Linux имеется несколько реализаций командной строки. Самая ранняя из
популярных реализаций, появившаяся еще в операционных системах-предках
Linux, называлась **Bourne shell (sh)**. На сегодняшний день самой
популярной и поставляемой в составе большинства дистрибутивов
является **Bourne-Again shell (bash)**.

Существуют и другие реализации, такие как **Korn shell (ksh)**, **Z
shell (zsh)**, **Almquist shell (ash)**, **Debian Almquist shell
(dash)** и другие.

Обычно на одной машине установлено несколько реализаций командной
строки, но только одна используется по умолчанию. Чтобы узнать,
какая работает у вас, введите команду:

    echo $SHELL

Если вы еще не знаете, куда ее ввести, читайте дальше.

Большинство реализаций совместимы с **sh**, но не обязательно совместимы
между собой. Например, скрипты и команды для *bash* не всегда работают
на *dash*. Есть и такие интерпретаторы команд, которые не совместимы с
*sh* (например, *C Shell \[csh\]*). Такие интерпретаторы не
рекомендуется (скорее всего, вообще невозможно)
использовать как интерпретаторы по умолчанию.

## Как запустить консоль

Существует два способа получить доступ к консоли: **виртуальные
консоли** и **эмуляторы терминала**.

### Виртуальные консоли

Виртуальные консоли доступны практически в любом дистрибутиве Linux для
настольных компьютеров и серверов.

Каждая виртуальная консоль позволяет вести отдельный сеанс работы с
компьютером. Если у вас есть, скажем, семь виртуальных консолей, то
семь пользователей могут совершить вход в систему и работать с ней
(правда, по очереди, поскольку монитор и клавиатура у вас одна).
Один пользователь может работать в нескольких консолях одновременно.

Чтобы открыть виртуальную консоль, используйте сочетание клавиш
**Ctrl+Alt+*FN***, где **N** — номер консоли. Например, **Ctrl+Alt+F1**
— первая консоль, **Ctrl+Alt+F2** — вторая, и так далее. Если вы уже
находитесь в виртуальной консоли, то на другую можно переключиться
этой же комбинацией но без Ctrl: *Alt+F1*, *Alt+F2*, и т.д.

Обычно настраивают шесть виртуальных консолей, а
[X-сервер](X-сервер "wikilink"), графическая система
GNU/Linux, работает в седьмой.

Здесь приведены настройки по умолчанию, они могут быть изменены.

Когда вы переключаетесь между виртуальными консолями, сеансы не
сбрасываются: вы в любой момент можете вернуться к любой
консоли, где вы выполнили вход, и продолжить работу.

Консоли называются виртуальными, поскольку изначально консолью назывался
терминал, с помощью которого подключались к мощному компьютеру-серверу и
работали. Таким образом, на одном сервере работало сразу несколько
пользователей. Виртуальные консоли симулируют работу таких
терминалов.

### Эмулятор терминала

Эмулятор терминала — это почти то же, что виртуальная консоль, только в
графическом режиме. Кроме того, обычно для работы в нем не требуется
выполнять вход. Консоль отображается в отдельном окне.

В большинстве случаев при работе в графическом режиме не требуется
обращаться к виртуальным консолям, консольные команды выполнятся с
помощью эмулятора терминала.

Существует много реализаций эмуляторов. Наиболее часто используемыми
являются: **gnome-terminal** (в среде [Gnome](Gnome "wikilink")),
**Konsole** (в среде [KDE](KDE "wikilink")), **xterm**, **rxvt**. Для
работы можно пользоваться любым из установленных.

Если вы считаете, что эмулятор терминала у вас не установлен, то вам
либо следует поискать еще раз, либо ваш дистрибутив очень странный.
Во втором случае можете воспользоваться пакетным менеджером и
установить его (для этого может потребоваться знание вашего
пароля/пароля супер-пользователя »root«).

**Внимание\! Эмулятор терминала (например, Konsole) и интерпретатор
команд (например, bash) — разные программы.**

Интерпретатор команд (он же **shell**) — это та программа, с которой вы
работаете в консоли, она исполняет ваши команды и запускает другие
программы.

Эмулятор терминала выводит окно для работы в консоли, подготавливает
сеанс работы и запускает интерпретатор команд.

## Как работать в консоли

### Подсказка (prompt)

Подсказка появляется, когда интерпретатор команд ждёт команду. Подсказка
может быть настроена как угодно, но обычно так:

    user@computer:/current/directory$

Где:

  - user — имя пользователя
  - computer — имя компьютера
  - /current/directory — *текущий каталог*. Обычно если текущий каталог
    — домашний каталог пользователя, то он сокращенно обозначается
    тильдой (\~).
  - $ — этот знак обозначает, является ли текущий пользователь
    суперпользователем ([root](root "wikilink")) или не
    является. Если является, то это решетка (\#), и если не
    является, то доллар ($). Когда вы работаете от имени
    суперпользователя (\#), будьте очень осторожны\! Примеры
    подсказки:

<!-- end list -->

    dmitry@debian:/tmp$

    root@debian:/root#

Кроме того, интерпретатор может выводить особую подсказку, если он ждет
продолжения предыдущей команды, а не новую команду. Обычно это просто
символ **\>**.

Внешний вид подсказки можно настроить под себя.

### Как устроена команда

Команда устроена так:

    <команда> [параметры]

Где:

  - **<команда>** — одно из следующих:
    1.  **Встроенная команда интерпретатора** (например, *export* или
        *alias*). Такую команду интерпретатор выполняет сам.
    2.  **Имя исполнимого файла, находящегося в известных директориях**.
        Список известных директорий содержится в переменной среды PATH,
        разделенный двоеточием (а не точкой с запятой, как в Windows).
        Интерпретатор найдет и запустит этот исполнимый файл, передав
        ему параметры для обработки. Например, *awk*.
    3.  **Путь к исполнимому файлу (прямой или относительно текущего
        каталога)**. Интерпретатор запустит этой файл, передав ему
        параметры для обработки. Например, */usr/bin/gcc*.

<!-- end list -->

  - **\[параметры\]** зависят от команды.

Продвинутые интерпретаторы, такие как bash, ради высокой скорости
исполнения поддерживают многие встроенные команды, которые обычно
реализуются при помощи внешних программ (например, *pwd*, *echo*,
*test*). Но это иногда может привести к неожиданным результатам, если
пользователь пытается вызвать известную ему программу, а вместо этого
интерпретатор сам обрабатывает команду.

**Обращаем внимание пользователей DOS и Windows**. Возможно, вы знаете,
что интерпретаторы команд **command.com** и **cmd.exe** при вводе имени
исполняемого файла ищут его не только в каталогах из переменной PATH, но
также в текущей директории. Кроме того, они автоматически присоединяют
расширение к имени исполняемого файла, если оно не указано.
Интерпретаторы команд в Linux не делают ни того, ни другого.
Если вам нужно запустить файл в текущей директории, можно это сделать,
например, так:

    ./program

Это будет уже относительный путь к файлу, т.е. пункт 3.

### Примеры простых команд

Команда **echo** выводит указанную строку на экран

    echo This is a test line

Команда **cp** (от *copy*) копирует файл или несколько файлов в
указанный каталог. Например, файлы /boot/grub/menu.lst
/etc/inittab и /etc/mtab в каталог /tmp:

    cp /boot/grub/menu.lst /etc/inittab /etc/mtab /tmp

...а также может поменять имя файла (/boot/grub/menu.lst -\>
/boot/grub/menu.lst.bak:

    cp /boot/grub/menu.lst /boot/grub/menu.lst.bak

Команда **cat** (от *catenate*, 'соединять') используется для вывода
содержимого файла или нескольких файлов:

    cat ~/Документы/Отчет

Или:

    cat ~/Документы/Первая_половина_отчета ~/Документы/Вторая_половина_отчета

Тильда обозначает домашний каталог пользователя.

### Текущий каталог и относительные пути

Скорее всего, вам уже понятно, как указать путь к файлу от корня
(например /boot/grub/menu.lst — в корневой директории папка\[1\]
boot, в ней папка grub, в ней файл menu.lst). Такой путь называется
**абсолютным путем**. В нем указана вся цепочка каталогов, которую
надо пройти, чтобы дойти до нужного файла или каталога.

Некоторые пути в этой статье начинаются с "\~". Это тоже абсолютные
пути, просто "\~" заменятся на абсолютный путь домашнего каталога
пользователя. Например: *\~/Документы/Письмо* →
*/home/vasya/Документы/Письмо*.

Но пользоваться только абсолютными путями было бы неудобно. Поэтому
существуют также **относительные пути**. Они указывают, как дойти
до каталога или файла X из каталога Y. Например:

*Подняться на одну директорию вверх\[2\], оттуда пойти в директорию
«Музыка», там будет файл justin_bieber.ogg:*

`../Музыка/justin_bieber.ogg`

Или: *найти директорию subdir в текущем каталоге, там файл text.txt:*

`subdir/text.txt`

Пути указываются относительно *текущего каталога*. При работе в консоли
текущий каталог обычно отображается в подсказке, но его всегда можно
узнать простой командой:

`pwd`

Можно легко сменить текущий каталог (обычно говорят: «перейти в другой
каталог») командой:

`cd "Другой каталог"`

Перейти в свой домашний каталог можно командой cd без параметров:

`cd`

**Внимание, пользователи DOS/Windows\!** Если вы привыкли пользоваться
командной строкой в этих системах, то обратите внимание: команда cd
без параметров значит «перейти в домашний каталог», а не что-либо
другое.

Вот так можно скопировать файл file1 в текущем каталоге в file2:

`cp file1 file2`

А так можно переместить file1 на каталог вверх, т.е. в родительский
каталог текущего каталога:

`mv file1 ..`

Еще можно перейти в родительский каталог и переместить файл после этого.
Допустим, мы находимся в каталоге mydir:

`cd ..`
`mv mydir/file1 .`

Отметим два специальных символа, использующихся в путях:

  - **. (точка)** — текущий каталог
  - **.. (две точки)** — родительский каталог

#### А где мой диск C:?

В ОС Windows имеется несколько корневых каталогов, по одному на каждый
диск: C:, D:, E: и так далее.

В Linux используется только один корневой каталог (/). В нём "находится"
содержимое одного из разделов жёсткого диска. Все прочие файловые
системы, в т.ч. другие разделы на жёстких дисках, CD/DVD-диски,
флешки и прочие сменные накопители *монтируются* (т.е. подключаются) в
подкаталоги. В этих подкаталогах и будет отображаться их содержимое.

О монтировании вручную см. команду .

В современных десктопных дистрибутивах сменные диски монтируются
автоматически, обычно в каталоги
/media/имя_пользователя/название_диска или
/var/media/имя_пользователя/название_диска. Например, если вставить
флешку с названием TOSHIBA TransMemory\[3\] в компьютер с Ubuntu и
ваше имя пользователя — vasya, файлы на ней будут в каталоге
"/media/vasya/TOSHIBA TransMemory". Это вовсе не значит, что они
автоматически скопируются на жёсткий диск, они будут на флешке,
но доступны по этому пути.

Обратите внимание, что автомонтирование дисков может быть настроено так,
что диски будут определяться автоматически, но не монтироваться. В этом
случае откройте менеджер файлов, кликните по нужному диску, и он
примонтируется. Скорее всего, директория, куда он
примонтировался, автоматически откроется.

Более того, в Linux существует ряд виртуальных файловых систем, которые
вообще не связаны с файлами на дисках. Это позволяет программам
получать доступ к устройствам или к каким-либо другим данным так
же, как к файлам. Например, в директории /dev находятся дескрипторы для
доступа к устройствам, а в директории /proc — для получения информации
от ядра ОС и управления им.

### Автодополнение

Кроме того, в консоли существует такая вещь, как автодополнение. Она
полезна в тех случаях, когда необходимо набрать длинную команду или
написать имя файла, содержащее много символов, которые необходимо
экранировать. Работает она очень просто. При наборе части команды
необходимо нажать \[TAB\] один или два раза и консоль либо дополнит
команду/имя файла, либо выдаст список для уточнения.

    [20:41:52][alex][~]: cd /home/alex/Ра
    [TAB]
    [20:41:52][alex][~]: cd /home/alex/Рабочий\ стол/

Однократное нажатие \[TAB\] дополнит имя программы/файла в том случае,
если его уже можно определить однозначно. Двойное нажатие выведет
список возможных "продолжений" команды:

    [20:41:52][alex][~]: ls /usr/share/ic
    [TAB][TAB]
    iceweasel/ icons/

### Специальные символы и их экранирование

Ряд символов в командах являются специальными символами. Это значит, что
они не передаются запускаемой программе или обработчику внутренней
команды shell'а, а обрабатываются ДО ТОГО, как команда будет
выполнена. То есть специальные символы управляют самим shell'ом.

Если вы хотите, чтобы shell не обрабатывал по-особому специальный
символ, а обрабатывал его как обычный символ, то его нужно
*экранировать*. Есть три способа это сделать:

  - Поставить обратный слэш (**\\**) перед специальным символом
    (по-английски этот метод называется *escape*). Сам обратный
    слэш, соответственно, тоже является специальным символом, и его
    можно так же экранировать (т.е. поставить два слэша: \\\\).
    Например:

`grep lucky\*star my\ file   #Ищем строку `*`lucky*star`*` в файле `*`my``
 ``file`*

  -
    Обратный слэш перед обычным, не специальным символом будет просто
    проигнорирован.

<!-- end list -->

  - Заключить команду или часть команды со специальными символами в
    двойные кавычки (**"**). По-английски этот метод называется
    *quote*. Двойные кавычки экранируют большинство специальных
    символов, но не все. Остальные спец. символы внутри двойных
    кавычек можно экранировать обратным слэшем. Пример:

`grep "lucky*star" "my file"   #Аналогично предыдущей команде`

  -
    Обратный слэш внутри двойных кавычек перед обычным символом или
    символом, который и без него экранируется в двойных кавычках,
    будет обработан как экранированный слэш. Но его можно и
    эксплицитно экранировать. Это значит, что команды **echo
    "hello, \\slash"** и **echo "hello, \\\\slash"** выведут на экран
    одно и то же: *hello, \\slash*.

<!-- end list -->

  - Заключить команду или часть команды в одинарные кавычки
    (по-английски этот метод тоже называется *quote*). Они
    экранируют все специальные символы. Пример:

`#Найти строку `*`$1000`*` в файле `*`my``   ``income`*
`grep '$1000' "my income"   #Символ '$' не экранируется двойными кавычками, а одинарными — экранируется.`

  -
    Обратный слэш внутри двойных кавычек всегда считается
    экранированным. Команда '''echo 'hello, \\\\slash' '''
    выведет на экран *hello, \\\\slash*. Это также означает, что нет
    никакой возможности экранировать одинарную кавычку внутри
    одинарных кавычек.

#### Список специальных символов

*По замыслу одного из участников... э-э... хорошо бы было здесь написать
таблицу спец. символов с указанием символа, экранируется ли в двойных
кавычках, в каких средах считается специальным, краткое описание, что
делает.*

### Вывод в файл и ввод из файла

#### Вывод результата работы в файл

Скорее всего, вам когда-нибудь придется записать весь вывод команды в
файл. Сделать это просто:

*`команда`*` >`*`имя``   ``файла`*

Например:

`#Найти все строки, содержащие подстроку "loruser" в файле /etc/passwd`
`#и записать их в файл "myfile" в директории "Документы" в домашней директории.`
`grep loruser /etc/passwd >~/Документы/myfile`

При этом учтите, что каждая программа имеет два потока вывода:
стандартный поток вывода и поток ошибок. Программа сама
определяет, какие сообщения в какой поток выводить. Если вы
перенаправите только поток вывода, то ошибки не будут записаны в
файл, а будут показаны на экране (и наоборот). Для перенаправления
потока ошибок используйте такой синтаксис:

*`команда`*` 2>`*`имя``   ``файла`*

Можно направить в файлы оба потока:

*`команда`*` >`*`файл_для_вывода`*` 2>`*`файл_для_ошибок`*

Пример:

`grep loruser /etc/passwd >~/Документы/myfile 2>~/Документы/myerrors`

При перенаправлении вывода или ошибок в файл файл будет полностью
перезаписан (или создан, если его нет). Даже если ничего не будет
выведено, файл будет перезаписан и заменен пустым.

Чтобы дописать вывод в конец файла, сохранив предыдущее содержимое,
используйте двойной знак "больше" вместо одинарного. То есть:

*`команда`*` >>`*`файл`*`   #Для вывода`
*`команда`*` 2>>`*`файл`*`   #Для ошибок`

#### Ввод из файла

Возможно, у вас возникнет и другой вопрос: как заставить программу
считать данные из файла, как если бы их вводили с клавиатуры?

Ответ на этот вопрос такой. **Практически все популярные программы, для
которых это имеет смысл, сами умеют читать данные из файла. Узнайте,
как использовать эту функцию в нужной вам программе и пользуйтесь
ею.**

Но если вы уверены, что такой функции нет, вы все же можете направить
данные из файла в поток ввода программы:

*`команда`*` < `*`файл`*

Да, можно комбинировать перенаправление ввода и вывода:

*`команда`*` < `*`файл_для_ввода`*` > `*`файл_для_вывода`*

Еще раз повторим, что если программа сама умеет читать данные из файла,
то лучше пусть читает сама. Это, скорее всего, более надежно и
эффективно.

#### Пользуйтесь функциями эмулятора терминала

Если вы пользуетесь эмулятором терминала, то он, вполне возможно, сам
умеет копировать текст текущего сеанса в буфер, сохранять в файл или
имеет другие подобные функции, которые могут облегчить вам работу.
Чтобы узнать о них, посмотрите в меню в нем или прочитайте
руководство пользователя.

#### Дальнейшее чтение

То, что написано в этом разделе статьи — это частные случаи
перенаправления потоков ввода и вывода. Вообще эта тема
довольно глубокая и если вы хотите эффективно работать в командной
строке или писать скрипты, вам нужно освоить ее лучше.

Собственно, именно эта функция и делает shell тем гибким инструментом,
которым он является. Вы можете сооружать цепочки команд (англ.
*[pipeline](http://en.wikipedia.org/wiki/Pipeline_\(software\))*), в
которых каждая программа будет обрабатывать данные и результат
подавать на вход следующей программе. Используя программы, каждая
из которых предназначена для конкретной простой операции, вы сможете
писать скрипты для решения любой стоящей перед вами задачи.

## Получение справки по командам

Практически в любой unix-подобной ОС (за исключением встраиваемых) есть
руководства по командам (manual) и команда man, служащая для просмотра
этих руководств. Если набрать, например, команду:

    man man

то на экране откроется справка по команде man (описание, какие параметры
она принимает и т.п.).

Так же существуют мануалы в формате »Info«. Этот формат поддерживает
разбивку на главы и своего рода (гипер)ссылки.

Пример использования:

    info info

Если вам в ответ на ваш вопрос пишут: "RTFM", "кури маны", то весьма
вероятно ответ на вопрос может быть легко найден с помощью
приведённых выше команд.

## Разделение прав и о работе под рутом

**Основная статья о root: [Суперпользователь (root)](root "wikilink")**

**Основная статья о правах: [Права доступа к
файлам](Права_доступа_к_файлам "wikilink")**

Суперпользователь (root) — это пользователь, для которого не проверяются
права на доступ к файлам. Для входа под именем суперпользователя
воспользуйтесь командой *su* без параметров. Для исполнения
одной команды от имени суперпользователя воспользуйтесь *sudo
<команда>*. Скорее всего, система попросит вас ввести пароль — либо
пароль суперпользователя, либо пароль от вашего аккаунта, в зависимости
от настроек.

Настоятельно не рекомендуется входить под именем root, а только
исполнять команды с использованием sudo в случае необходимости.
Разумеется, не рекомендуется запускать программы, полученные из
сомнительных источников, с правами суперпользователя. Не
рекомендуется также выполнять от имени root команды, которых вы
не понимаете. Вообще говоря, программы из сомнительных источников и
непонятные команды вообще выполнять не рекомендуется.

Иногда нехорошие люди "шутят" над новичками, рекомендуя им выполнить
команду "sudo rm -rf /" или "sudo rm -rf /\*". Как можно понять,
прочитав "man rm", эта команда удалит все файлы на жёстком диске.
Впрочем, в современных дистрибутивах либо сам shell, либо rm может
спросить подтверждение. Поэтому теперь обычно советуют выполнить "rm
-rf \~/\*", которая удалит все файлы в домашнем каталоге пользователя.

## Заключение

После чтения этой статьи вы должны знать, что такое командная строка,
как получить к ней доступ на вашем компьютере, какие бывают команды и
как их вводить, как сохранить данные в файл и как дать программе на
обработку данные из файла.

Большинство утилит командной строки работают одинаково во всех
дистрибутивах, в отличие от графических утилит. Поэтому не
удивляйтесь, если в ответ на вопрос на форуме вас попросят ввести
какую-либо команду: скорее всего, вам предлагают наиболее
универсальное решение.

Если вам хочется узнать больше о возможностях командной строки, о том,
как комбинировать команды и так далее, прочтите руководство к вашему
интерпретатору команд. В случае *bash* рекомендуем прочитать *Advanced
Bash Scripting Guide*, он есть и в переводе на русский. Надеемся также,
что и в этой Вики появятся статьи об использовании командной строки.

## Примечания

<references>

  - В общем, надо, чтобы «чайник» в случае необходимости мог
    воспользоваться консольной утилитой или хотя бы
    выполнить команду, которую ему подскажут на форуме.

<!-- end list -->

1.  Некоторые посетители linux.org.ru приходят в бешенство от слова
    «папка» в значении «каталог»/«директория», но вы на них не
    обращайте внимания
2.  Т.е. в ту, где находится текущий каталог
3.  На самом деле, играет роль не название, а метка раздела, но если вы
    сами не умеете форматировать диски, то не будете знать разницы.