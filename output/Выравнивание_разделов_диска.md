# Теория

## Термины

  - сектор - минимальная адресуемая единица хранения информации на
    дисковых запоминающих устройствах
    [1](http://ru.wikipedia.org/wiki/Сектор_диска)
  - блок - размер данных, установленный для обмена с блочным устройством

Важно, что размер сектора определяется оборудованием (например, диск
сообщает ОС, что размер сектора = 512 байт), а размер блока -
операционной системой ( например, размер блока установим в 8
секторов )

  - раздел - как disk volume, так и logical volume и любой контейнер для
    хранения данных( зашифрованный диск, например). Может быть,
    кто-нибудь сформулирует точнее.

## Суть проблемы

Без выравнивания разделов скорость работы с диском ниже (иногда -
намного ниже) ожидаемой.

**Например**:

Не используется ни LVM, ни аппаратный рейд, ни какой-либо ещё способ
виртуализации дисковой подсистемы, размер блока ext3 = 4k, WD20EARS
(в нем используется advanced format в терминологии WesternDigital)

Если раздел начинается с сектора 63, скорость записи падает на 30 % по
сравнению с разделом, начинающимся с сектора 2048

## История проблемы

Выравнивать разделы начали задолго до того, как эта проблема коснулась
домашнего пользователя - аппаратные рейды, виртуализация, san диски
требовали грамотной настройки. Но после того, как размер обычного
домашнего жёсткого диска дошёл до 2 Тб, выравнивание блоков данных
попало в область внимания хомячков.

По сомнительным historical reason (соображениям совместимости со всяким
хламом вроде windows 98), разделы диска до сих пор выравниваются по так
называемой границе цилиндра ( см. [геометрия жёсткого
диска](http://ru.wikipedia.org/wiki/Жёсткий_диск#.D0.93.D0.B5.D0.BE.D0.BC.D0.B5.D1.82.D1.80.D0.B8.D1.8F_.D0.BC.D0.B0.D0.B3.D0.BD.D0.B8.D1.82.D0.BD.D0.BE.D0.B3.D0.BE_.D0.B4.D0.B8.D1.81.D0.BA.D0.B0)
) , и число секторов в разделе должно быть кратно 63. Хотя это давно не
соответствует реальной геометрии диска, которая прячется от нас
электроникой жёсткого диска.

Диски большой ёмкости имеют размер сектора 4096 байт вместо обычных 512,
но в целях совместимости со старыми ОС представляются как диски с
размером сектора 512 байт. И если размер блока файловой системы
больше логического 512-байтного сектора, при записи мы получаем
проблему: один блок ФС расположен на двух физических секторах
диска. Частично это компенсируется электроникой и буфером жёсткого
диска, но производительность всё равно падает.

Это о "домашней" проблеме. А то же самое справедливо для выравнивания
блоков и страйпов RAID-массива, блоков диска host системы, и т.д.

А в случае использования SSD дисков отсутствие выравнивания ещё и
быстрее расходует лимит на запись блока SSD.

В результате, разделы больше нельзя выравнивать по границе цилиндров.
Тогда по какой границе?

1.  граница разделов должна быть кратной 4 КиБ, из-за дисков с размером
    сектора 4096
2.  Размер GPT - 33 сектора, поэтому если мы не хотим каждый раз
    вспоминать, какая же у нас разметка - dos или GPT - нужно
    начинать первый раздел не ранее 34 сектора
3.  в SSD дисках минимальная стираемая единица информации зависит от
    производителя, но как правило 128 КиБ, поэтому если мы не хотим
    каждый раз вспоминать, что у нас за диск ... К тому же, программы
    для разметки диска тем более не обязаны знать все модели.
4.  желательно, чтобы при использовании аппаратного RAID у нас тоже не
    возникало проблем, а там размер chunk бывает разный, нередко и 512
    КиБ.

Откуда взялась цифра 1 МиБ, я так и не нашёл. Есть мнение, что это ИМХО
Microsoft [2](http://support.microsoft.com/kb/929491), ставшее
неофициальным стандартом

## Производительность

# Практика: Выравниваем данные

## Оно мне надо?

  - Если скорость работы жёсткого диска устраивает, всё бросать и
    переразбивать диск не стоит.
  - Если диск новый и вы приступили к разметке, обязательно выравнивайте
    разделы по границе 1 МиБ.
  - Диск новый, а скорость намного ниже ожидаемой. Тогда переразбить
    стоит, но нужен полный бекап всех данных

Проверить скорость записи (если диск не Advanced Format) можно так: если
подозреваемый раздел смонтирова в /home/, запишем туда 100 Мб файл
(лучше больше) и посмотрим скорость

`dd if=/dev/zero of=/home/test.raw bs=128k count=800 `**`oflag=direct`**

Если в выводе

`fdisk -lu /dev/sda | grep '^\/' | while read disk start other; do`
`    if [ ! "$((  $start % 2048 ))" -eq "0" ]; then`
`        echo "$disk not aligned";`
`    fi;`
`done`

есть строки вида

/dev/sda1 not aligned

то раздел не выровнен

Или через parted:

`jb:~# parted /dev/sda align-check opt 1`
`1 aligned`

## Выравнивание разделов

Итак, разделы нужно выравнивать по границе 1 МиБ, т.е. по границе 2048
секторов. Т.е. первый раздел начинается с 2048 сектора

### fdisk

Для создания выравненных разделов через fdisk нужно использовать ключи
-c и -u

`fdisk -c -u /dev/sdc`

**Если дистрибутив старый** и fdisk не понимает ключ -u, использовать
один -c, но число секторов рассчитывать вручную, например, через bash

Пример ручного расчёта: нужно создать первый раздел размером 100 МиБ

Начало раздела

`echo $(( 2048 * 1 ))`

конец раздела

`echo $(( 2048 * ( 1 + 100 ) - 1 ))`

### parted

Для создания выравненных разделов через parted нужно использовать
параметр **-a optimal**

`parted -a optimal`

## Метаданные ФС, LVM и т.п.

При использовании LVM, software raid и т.п., на разделе А создаётся
раздел Б ( меньшего размера ) и плюс на разделе А храняться
метаданные. Эти метаданные и способ организации нового раздела
так же нужно учитывать для выравнивания данных.

Если метаданные расположены в конце раздела А, они не влияют на смещение
раздела Б и, соответственно, на выравнивание данных на разделе Б.

### software raid

  - метаданные: завичит от версии метаданных (определяется при создании
    рейда)


  -   - 1.0 - в конце диска
      - 1.1 - в начале диска
      - 1.2 - в 4 КиБ от начала диска.

**FIXME:** нужно уточнить, можно ли явно задать границу выравнивания
данных

Не нашёл в man mdadm. Проверил на практике md4 - software raid, metadata
v1.2, один из дисков рейда - sde

ищём что-нибудь уникальное среди данных

`# hexdump /dev/md4 -C | head -n 5`
`00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|`
`*`
**`00000200`**`  4c 41 42 45 4c 4f 4e 45  01 00 00 00 00 00 00 00  |`**`LABELONE`**`........|`

теперь то же самое - на одном из дисков массива

`# dd if=/dev/sde bs=1M count=100 | hexdump -C | grep `**`LABELONE`**
**`00100200`**`  4c 41 42 45 4c 4f 4e 45  01 00 00 00 00 00 00 00  |LABELONE........|`
`100+0 записей считано`
`100+0 записей написано`
` скопировано 104857600 байт (105 MB), 1,49776 c, 70,0 MB/c`

Проверяем (для примера - двумя способами :))

`# echo $((0x100000))`
`1048576`
`# echo $((512*2048))`
`1048576`
`# echo 'obase=16;512*2048'  | bc`
`100000`

, данные в software raid c metadata v1.2 начинаются с 1 МиБ, т.е.
выровнены.

### LVM

  - метаданные: в начале раздела

Выравнивание данных задаётся ключём **--dataalignment** при создании PV:

`pvcreate --dataalignment=`**`1M`**` /dev/sdc1`

Проверяем через pvs:

` # pvs -o+pe_start /dev/sdc1`
` PV         VG   Fmt  Attr PSize   PFree   1st PE`
` /dev/sdc1       lvm2 a-   100,00m 100,00m   `**`1,00m`**

### LUKS

  - Метаданные: в начале раздела

При создании LUKS, выравнивание данных относительно начала раздела
задаётся в явном виде, через параметр

  - **--align-payload** <количество секторов>

Т.е. при создании раздела

`cryptsetup --align-payload `**`2048`**` luksFormat /dev/mapper/vgdata-lvcrypt`

данные будут выравниваться по границе 1 МиБ относительно начала
/dev/mapper/vgdata-lvcrypt Проверять через

`cryptsetup luksDump /dev/mapper/vgdata-lvcrypt | grep Payload`

# see also

  - <http://www.redhat.com/f/pdf/summit/msnitzer_1120_optimize_storage.pdf>
  - man blockdev
  - man mkfs.ext3 ( влияние stripe и stride на производительность ext )
  - <https://ata.wiki.kernel.org/index.php/ATA_4_KiB_sector_issues>

